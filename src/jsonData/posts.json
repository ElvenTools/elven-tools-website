[{"fileName":"cli-commands.html","title":"CLI Commands","body":"<ul>   <li><code>elven-tools derive-pem</code> - derives the PEM file from seed phrase (keywords)</li>   <li><code>elven-tools collection-nft-owners</code> - get collection nft owners using the collection ticker (<a href=\"/docs/recipes#how-to-get-owners-addresses-using-the-collection-ticker\">see more</a>)</li>   <li><code>elven-tools deploy nft-minter</code> - deploys the smart contract (by default from the defined tag branch using the devnet, can be configured)</li>   <li><code>elven-tools nft-minter issue-collection-token</code> [only owner] - issue main collection handle, it costs 0.05 EGLD, and it is a must in the Elrond chain. All NFTs will be under this collection. The cost here is a one-time payment for the whole collection.</li>   <li><code>elven-tools nft-minter set-roles</code> [only owner] - for now, the command sets the critical role for the collection handle. It is a 'create nft' role.</li>   <li><code>elven-tools nft-minter start-minting</code> [only owner] - by default, after deploying the smart contract, the minting is disabled. You would need to start it</li>   <li><code>elven-tools nft-minter pause-minting</code> [only owner] - you can also pause it at any moment</li>   <li><code>elven-tools nft-minter set-new-price</code> [only owner] - you can set a new price per NFT for the whole collection</li>   <li><code>elven-tools nft-minter giveaway</code> [only owner] - as an owner, you can give some random tokens to other addresses. (<a href=\"/docs/recipes#how-to-use-the-giveaway\">see more</a>)</li>   <li><code>elven-tools nft-minter set-drop</code> [only owner] - you can also split the minting into drops. These are 'waves' of minting where you can change prices and promote each one (v1 doesn't include any logic for revealing the CIDs with delay, the revealed NFTs will be sent in every drop). (<a href=\"/docs/recipes#how-to-use-drops\">see more</a>)</li>   <li><code>elven-tools nft-minter unset-drop</code> [only owner] - you can also disable the drop and pause minting</li>   <li><code>elven-tools nft-minter claim-dev-rewards</code> [only owner] - as an owner of the Smart Contract, you can always claim the developer rewards. Read more about them in the Elrond docs. (<a href=\"/docs/recipes#how-to-claim-dev-rewards\">see more</a>)</li>   <li><code>elven-tools nft-minter change-base-cids</code> [only owner] - you can change base IPFS CIDs only before any NFT was minted. Otherwise, it doesn't make sense to do that.</li>   <li><code>elven-tools nft-minter set-new-tokens-limit-per-address</code> [only owner] - it is possible to change the limits per address which are configured when deploying the Smart Contract</li>   <li><code>elven-tools nft-minter claim-sc-funds</code> [only owner] - this is treated as a fallback for royalties. The Smart Contract will receive the royalties as the creator, so there has to be a way to get them back. In the future the Smart Contract will probably also have dedicated claim functionality to be able to call the marketplace and get the royalties because some of the marketplaces don't send them automatically. (<a href=\"/docs/recipes#how-to-claim-royalties-and-other-funds\">see more</a>)</li>   <li><code>elven-tools nft-minter shuffle</code> - as a user, you can take part and ensure that the minting is random. This transaction will reshuffle the next index to mint. Everyone can run it.</li>   <li><code>elven-tools nft-minter mint</code> - the main mint function, you can mint NFTs using any <code>walletKey.pem</code> file</li>   <li><code>elven-tools nft-minter get-total-tokens-left</code> - the Smart Contract query, returns amount of tokens left</li>   <li><code>elven-tools nft-minter get-provenance-hash</code> - the Smart Contract query returns the provenance hash if provided when deploying</li>   <li><code>elven-tools nft-minter get-drop-tokens-left</code> - the Smart Contract query returns the number of tokens left per drop</li>   <li><code>elven-tools nft-minter get-nft-price</code> - the Smart Contract query, returns the current price</li>   <li><code>elven-tools nft-minter get-nft-token-id</code> - the Smart Contract query, returns the collection token id</li>   <li><code>elven-tools nft-minter get-nft-token-name</code> - the Smart Contract query, returns the collection token name</li>   <li><code>elven-tools nft-minter get-tokens-limit-per-address-total</code> - the Smart Contract query returns the tokens limit per address</li>   <li><code>elven-tools nft-minter get-minted-per-address-total</code> - the Smart Contract query returns the number of tokens minted per one address</li>   <li><code>elven-tools nft-minter get-minted-per-address-per-drop</code> - when the drop is configured, it will return the number of tokens minted per address per drop</li>   <li><code>elven-tools nft-minter get-tokens-limit-per-address-per-drop</code> - when the drop is configured, it will return the total limit of tokens per address per drop</li>   <li><code>elven-tools nft-minter populate-allowlist</code> - the command for preparing the allowlist, you will be able to read it for <code>sc/nft-minter/allowlist.json</code> file or you can provide addresses by hand. There is a limit of 250 addresses per transaction (<a href=\"/docs/recipes#how-to-use-allowlist\">see more</a>)</li>   <li><code>elven-tools nft-minter enable-allowlist</code> - enable the allowlist, it won't be onsidered unles enabled even when it is filled with addresses,</li>   <li><code>elven-tools nft-minter disable-allowlist</code> - the option to disable the allowlist,</li>   <li><code>elven-tools nft-minter get-allowlist-size</code> - check the size of the allowlist,</li>   <li><code>elven-tools nft-minter is-allowlist-enabled</code> - check if allowlist is currently enabled,</li>   <li><code>elven-tools nft-minter get-allowlist-address-check</code> - check if provided address is included in the allowlist,</li>   <li><code>elven-tools nft-minter is-drop-active</code> - checks if there is an active drop at the moment</li> </ul>","excerpt":"Here you will find all CLI commands with short descriptions.","publicationDate":"2022-01-25","tags":["cli tool"],"coverImage":""},{"fileName":"cli-introduction.html","title":"CLI Introduction","body":"<p>The CLI tools is a standard Node CLI program which you can install using the npm package manager. It is best to install it globally by:</p> <pre><code class=\"language-bash\">npm install elven-tools -g </code></pre> <h3>What is it?</h3> <ul>   <li>The CLI tool helps to:     <ul>       <li>deploy the NFT minter Smart Contract on the Elrond blockchain</li>       <li>interact with the NFT minter Smart Contract on the Elrond blockchain</li>     </ul>   </li> </ul> <p>For now it is designed to deploy the contract: <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">elven-nft-minter-sc</a>.</p> <h3>How does it work?</h3> <p><strong>General how to:</strong></p> <ul>   <li><code>npm install elven-tools -g</code></li>   <li><code>elven-tools --version</code> or <code>elvent-tools -v</code></li>   <li><code>elven-tools --help</code> or <code>elven-tools -h</code> - for getting the commands on the root level</li>   <li><code>elven-tools nft-minter --help</code> or <code>elven-tools nft-minter -h</code> - for getting all the commands for the subcommand</li> </ul> <p><strong>Steps for deploying and interacting with the Smart Contract:</strong></p> <p>Check the detailed steps here: <a href=\"/docs/jump-start.html\">Jump start section</a>.</p> <p>Be aware that, by default, all will happen on the devnet. See <a href=\"/docs/recipes.html#how-to-use-the-configuration-file\">here</a> how to change it.</p> <p>Check all commands <a href=\"/docs/cli-commands.html\">here</a></p> <h3>Custom configuration options</h3> <p>Below is an example of a <code>.elventoolsrc</code> config file with default values. You don't have to change the <code>config.ts</code> file. It is for library usage. <code>.elventoolsrc</code> is the only config file that should be used. It is not required if you will work on the devnet with the defined tag branch of the Smart Contract. In other cases, you would need to have it. It should be located in the same directory from which the <code>elven-tools</code> commands are triggeredâ€”the same directory as the one where the <code>walletKey.pem</code> file is located.</p> <pre><code class=\"language-json\">{   \"chain\": \"devnet\",   \"customProxyGateway\": \"https://devnet-gateway.elrond.com\",   \"nftMinter\": {     \"version\": \"{tag version here or branch name, for example: v1.2.0}\",     \"deployGasLimit\": 120000000,     \"issueCollectionTokenGasLimit\": 80000000,     \"issueValue\": \"0.05\",     \"assignRolesGasLimit\": 80000000,     \"issueTokenFnName\": \"issueToken\",     \"setLocalRolesFnName\": \"setLocalRoles\",     \"mintBaseGasLimit\": 14000000,     \"tokenSelingPrice\": \"\",     \"mintFnName\": \"mint\",     \"giveawayBaseGasLimit\": 11000000,     \"giveawayFnName\": \"giveaway\",     \"setDropFnName\": \"setDrop\",     \"setUnsetDropGasLimit\": 12000000,     \"unsetDropFnName\": \"unsetDrop\",     \"pauseUnpauseGasLimit\": 5000000,     \"pauseMintingFnName\": \"pauseMinting\",     \"unpauseMintingFnName\": \"startMinting\",     \"setNewPriceGasLimit\": 5000000,     \"setNewPriceFnName\": \"setNewPrice\",     \"shuffleFnName\": \"shuffle\",     \"shuffleGasLimit\": 6000000,     \"getTotalTokensLeftFnName\": \"getTotalTokensLeft\",     \"getProvenanceHashFnName\": \"getProvenanceHash\",     \"getDropTokensLeftFnName\": \"getDropTokensLeft\",     \"getNftPriceFnName\": \"getNftPrice\",     \"getNftTokenIdFnName\": \"getNftTokenId\",     \"getNftTokenNameFnName\": \"getNftTokenName\",     \"getMintedPerAddressTotalFnName\": \"getMintedPerAddressTotal\",     \"getTokensLimitPerAddressTotalFnName\": \"getTokensLimitPerAddressTotal\",     \"getMintedPerAddressPerDropFnName\": \"getMintedPerAddressPerDrop\",     \"getTokensLimitPerAddressPerDropFnName\": \"getTokensLimitPerAddressPerDrop\",     \"changeBaseCidsFnName\": \"changeBaseCids\",     \"changeBaseCidsGasLimit\": 5000000,     \"setNewTokensLimitPerAddressFnName\": \"setNewTokensLimitPerAddress\",     \"setNewTokensLimitPerAddressGasLimit\": 5000000,     \"claimScFundsFnName\": \"claimScFunds\",     \"claimScFundsGasLimit\": 6000000,     \"populateIndexesBaseGasLimit\": 5000000,     \"populateIndexesMaxBatchSize\": 2200,     \"allowlistBatchSize\": 250,     \"populateIndexesFnName\": \"populateIndexes\",     \"populateAllowlistFnName\": \"populateAllowlist\",     \"populateAllowlistBaseGasLimit\": 6000000,     \"getAllowlistFnName\": \"getAllowlistSize\",     \"isAllowlistEnabledFnName\": \"isAllowlistEnabled\",     \"getAllowlistAddressCheckFn\": \"getAllowlistAddressCheck\",     \"enableAllowlistFnName\": \"enableAllowlist\",     \"disableAllowlistFnName\": \"disableAllowlist\",     \"enableDisableAllowlistGasLimit\": 6000000,     \"isDropActiveFunctionName\": \"isDropActive\"   },   \"collectionNftOwners\": {     \"apiCallsPerSecond\": 5   } } </code></pre> <p><strong>Whole config with default values:</strong> <a href=\"https://github.com/ElvenTools/elven-tools-cli/blob/main/src/config.ts\">config.ts</a></p> <p>Remember, you don't have to change the <code>config.ts</code> file. It is for library usage. You don't have to clone the repository to change the configuration. <code>.elventoolsrc</code> is the only config file that should be used.</p> <h3>Limitations and caveats</h3> <ul>   <li>there are main limitations related to the Smart Contract. Remember that it is most likely that this CLI tool won't be used only in a way that everyone would want to, be aware that you can always change the names of the endpoints in the Smart Contract. Then you can also use the config file and change them here in the CLI</li>   <li>Smart Contract in version 1 doesn't have many mechanisms which will strongly limit unwanted behaviors. It only implements random minting, but in version 2, there will be more mechanisms for fair launches.</li> </ul> <h3>Issues and ideas</h3> <p>Please post issues and ideas <a href=\"https://github.com/ElvenTools/elven-tools-cli/issues\">here</a>.</p> <h3>Contact</h3> <ul>   <li><a href=\"https://t.me/juliancwirko\">Telegram</a></li>   <li><a href=\"https://twitter.com/JulianCwirko\">Twitter</a></li>   <li>julian.cwirko@gmail.com</li> </ul>","excerpt":"The CLI tools is a standard Node CLI program which you can install using the npm package manager.","publicationDate":"2022-01-26","tags":["cli tool"],"coverImage":""},{"fileName":"elven-tools-workflows.html","title":"Elven Tools workflows","body":"<p>Many possible endpoints on the <a href=\"/docs/sc-introduction.html\">Smart Contract</a>. There is also a lot of documentation <a href=\"/docs/jump-start.html\">here</a> and <a href=\"/docs/cli-introduction.html\">there</a>. But how exactly should one work with the Elven Tools? Let's see the options and how you could sell and distribute your NFTs.</p> <h3>What we will tackle here</h3> <ol>   <li>What you can do and what you can't do with the first version of Elven Tools.</li>   <li>Examples of the scenarios and how to configure them.</li> </ol> <p>All scenarios can be modified and improved. These are probably the most often used scenarios on how to run the collection using Elven Tools.</p> <h3>What is possible and what's not</h3> <p>The first version of the Smart Contract works on the trendy principle of a 'candy machine'. You can read more about it here: <a href=\"/docs/tips-on-buying-nfts-on-the-elrond-blockchain.html\">Tips on buying NFTs on the Elrond blockchain</a>.</p> <p>In general, you pay, and you get randomly selected NFT. In the article linked above, you will find some more thoughts about the pros and cons of such a solution, but here let's focus on exactly what you can do and what you can't.</p> <p><strong>You can:</strong></p> <ul>   <li>you can receive the EGLD, randomly mint the NFT and send it to the buyer</li>   <li>you can split the whole collection into minting 'waves', called 'drops' here</li>   <li>you can give away tokens to chosen addresses (this is also randomly minted)</li>   <li>you can prepare an 'allowlist' and allow only eligible addresses to mint, then you can enable or disable it at any given time</li>   <li>you can start and pause the minting at any given time</li>   <li>you can change prices at any given time (of course should be appropriately planned and communicated)</li>   <li>you can change the tokens limit per one address at any given time in total</li>   <li>you can claim royalties sent to the Smart Contract from a marketplace</li>   <li>you can claim the developer rewards (as an owner of the Smart Contract, you will get the rewards too, it is 30% of the fee of each Smart Contract call)</li> </ul> <p><strong>You can't:</strong></p> <ul>   <li>you can't postpone sending the NFT token to the buyer's wallet</li>   <li>you can't send the NFT token with hidden assets</li>   <li>you can't take other currency than EGLD (at least for now, there are plans to implement that)</li>   <li>you can't disable the random minting functionality - it is essential for fair distribution</li> </ul> <p>There is another version of the contract planned, or it is better to say, a new Smart Contract that will implement another approach to fair distribution. You can read about it in the article linked above. Ok, enough theory, let's see the practical scenarios to use.</p> <h3>Examples of scenarios</h3> <p>Please keep in mind that these are only my ideas, you don't have to do this that way, and you can mix all possible endpoint calls to achieve your perfect flow. These are just examples to explain why all the endpoints are there. I will also describe how to prepare all of that using the Elven Tools CLI because it is simpler and faster. But you could also prepare the Smart Contract without it, for example, using <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy\">erdpy</a>.</p> <p><strong>Let's list all of my ideas on how we can do this first:</strong></p> <ol>   <li>Simple minting - all at once.</li>   <li>Simple minting with allowlist - all at once with allowlist.</li>   <li>Minting is divided into drops with different prices.</li>   <li>Minting with a giveaway.</li>   <li>A little bit of everything.</li> </ol> <p>Remember that all of the described below transactions are owner only, which means that the only owner of the Smart Contract can run it. So the wallet which deploys the Smart Contract.</p> <p><strong>Simple minting - all at once</strong></p> <p>Elven Tools allows mint without configuring other stuff like allowlist, drops, etc. You need to go through the required steps after deployment and start the minting process. You'll find all info about how to deploy and configure initial stuff here: <a href=\"/docs/jump-start.html\">Elven Tools Jumpstart</a>.</p> <p>When you deployed and ran all required transactions, you will be able to start minting. Let's see how.</p> <p>To start minting, you have to run the command:</p> <pre><code>elven-tools nft-minter start-minting </code></pre> <p>Of course, we assume that the Smart Contract is correctly deployed, the collection token is issued, it has proper roles, and the shuffle endpoint was called at least once. Again, you will find all about it here: <a href=\"/docs/jump-start.html\">Elven Tools Jumpstart</a>. Please let me know if something there is still not clear. I will improve the docs.</p> <p>That's it. Now your community can freely buy and mint the tokens till the end of the collection. You don't have to do anything more. Of course, you can still pause the minting:</p> <pre><code>elven-tools nft-minter pause-minting </code></pre> <p>And you can do whatever you need. You can even change the price. This isn't like you need to decide on one scenario. Remember about that. But for simplicity, I want to focus on examples.</p> <p>Pros of such an approach:</p> <ul>   <li>simplicity - you don't have to care about additional promotion and setup</li>   <li>if a project is quite popular, the collection will be probably sold out in a couple of minutes or hours</li> </ul> <p>Cons of such approach:</p> <ul>   <li>you won't have many tools to build the community and hype around it,</li>   <li>it can be heavy for your dapp, so it should be well prepared in such a case. Don't rely on public API or build the website with cache solutions. But generally, don't rely on public API if you can ;)</li> </ul> <p>It is a straightforward scenario and probably not very often used. Let's see what more we can do.</p> <p><strong>Simple minting - all at once with allowlist</strong></p> <p>This scenario is the same as the one above. What is added here is the 'allowlist'. A list of prepopulated addresses on the Smart Contract will be the only ones that can mint if the 'allowlist' is enabled. Let's see what we need to make it happen.</p> <p>First, you would need to populate the 'allowlist' with addresses. You can do this using the JSON file with a max of 250 addresses per one transaction or providing them by hand using a CLI prompt.</p> <p>If you can, please prepare the <code>allowlist.json</code> file and put it in the <code>sc/nft-minter</code> relative to where you keep your walletKey.pem file and from where you run the <code>elven-tools</code> commands.</p> <p>You need to run the command:</p> <pre><code>elven-tools nft-minter populate-allowlist </code></pre> <p>The CLI will detect it and ask you if you want to continue.</p> <p>If you have more than 250 addresses, please repeat the operation. Remember to replace old addresses with new ones in the allowlist.json file. If you send the same addresses again, nothing will happen, there is no way to have duplicates on the smart contract, but you will lose some EGLD on the transaction fees.</p> <p>To provide addresses by hand, you would need to run the same command but remove or change the name of the <code>allowlist.json</code> file. Then the CLI will ask you to provide the addresses by hand. You can use commas to separate them.</p> <p>When the list is populated, you need to enable the 'allowlist'. You can do this by running:</p> <pre><code>elven-tools nft-minter enable-allowlist </code></pre> <p>From now on, only eligible addresses can mint. You would probably handle it in your dapp, but generally, if someone tries to mint and their address isn't on the list, the transaction will fail.</p> <p>You can disable the allowlist at any given time by:</p> <pre><code>elven-tools nft-minter disable-allowlist </code></pre> <p>Then standard minting starts, and every address can mint.</p> <p>It is important that the 'allowlist' does not keep the information about how many tokens a particular address can mint. The Smart Contract will respect global settings, total limits per the whole collection, and limits per drop. These limits can be changed at any given time. Please refer to the <a href=\"/docs/cli-commands.html\">docs</a> on how to do that.</p> <p>Ok, now we know how to use the 'allowlist' to promote and organize the presale for only eligible addresses.</p> <p>Pros of such an approach:</p> <ul>   <li>all the pros from the previous scenario</li>   <li>allowlist lets you organize the presale. You can also change prices after allowlist is disabled</li> </ul> <p>Const of such approach:</p> <ul>   <li>all the cons from the previous scenario</li>   <li>you need to handle this in your dapp not to confuse users. There are queries available on the Smart Contract, which will allow checking if the 'allowlist' is enabled and also to check if an address is on the list</li> </ul> <p><strong>Minting divided into drops with different prices</strong></p> <p>As I wrote before, you can mix all of the scenarios. You can also use the 'allowlist' here. Here let's focus only on the 'drops' functionality.</p> <p>The 'drops' functionality is optional. You don't have to use these to mint/sell. It is useful to divide your process into 'waves' spread in time. You have 9999 tokens in a collection, and you would like to have three drops/waves of minting each of 3333 NFTs. You can prepare the whole marketing for that and also the price strategy.</p> <p>What is essential here, and for many, it is a con of such a Smart Contract, is that when you distribute the first drop, it will for sure land on the second market. But it isn't always bad. You could check how prices form around that and adjust your fees for the next drop. Of course, it is better not to reveal prices for the following drops in such a case.</p> <p>Ok, so how to configure these?</p> <p>First, you would need to set the first drop:</p> <pre><code>elven-tools nft-minter set-drop </code></pre> <p>You will be asked how big is the drop, so with our example, it will be 3333 tokens, and what is the limit per one address per one drop. The limit per drop can be different than the total limit per collection, but it should always be smaller than the total limit. That's all that you need to do. Then you would need to start minting. After all 3333 tokens are sold, the Smart Contract will pause the minting process automatically. Of course, you would need to handle this on the dapp. Some queries will return how many tokens are already minted by drop and minted per one particular address. Please check all <a href=\"/docs/cli-commands.html\">here</a>.</p> <p>If needed, you can also unset/disable the actual drop.</p> <pre><code>elven-tools nft-minter unset-drop </code></pre> <p>You can also set another one at any time, which will overwrite the previous one. You won't select the amount bigger than tokens left to mint.</p> <p>What is important here is the possibility to set different prices for every drop. When the drop is sold out, you can change the price without starting the minting:</p> <pre><code>elven-tools nft-minter set-new-price </code></pre> <p>Then when the time comes, you can just set a new drop and start minting. Or you can even begin minting without setting the next drop.</p> <p>Pros of such a solution:</p> <ul>   <li>all from the previous scenarios</li>   <li>you will have a lot more control over the marketing and planning in time</li> </ul> <p>Const of such solution:</p> <ul>   <li>all from the previous scenarios</li>   <li>it is simpler for a mistake. You could start at the wrong moment or begin with the old price. Of course, you can pause it at any given time, but some tokens could be minted already</li>   <li>a lot of more planning is required and tests on the devnet</li> </ul> <p><strong>Minting with giveaways</strong></p> <p>The following interesting functionality is a <code>giveaway</code>. This is something which is used very often. It allows the operator to give randomly selected NFTs to any addresses they want. It could even be their address. Usually, it is used for marketing and rewarding in many different contests and lotteries in a project's community.</p> <p>You can use the giveaway endpoint at any given time. There will be no payment in this case. In most cases, it will probably be used initially, even before the process starts. But you can also use it in the middle of the process, but it is advisable to be careful when a drop is defined and active. It could affect the drop's final available amount of tokens if the drop is the last one, and there won't be any tokens left after using the giveaway. So use it at the beginning, the best even before the process starts or in between drops when the process is paused.</p> <p>Ok, let's see how to use it:</p> <pre><code>elven-tools nft-minter giveaway </code></pre> <p>You will be asked to provide the addresses in the CLI prompt. You can give/mint the tokens in this special case even when the whole minting process is paused.</p> <p>Remember that they will still be minted randomly. In the spirit of fair distribution, there is no way to choose a particular one to send.</p> <p>Pros of such a scenario:</p> <ul>   <li>all from the previous scenarios</li>   <li>you will be able to thank anyone you need to thank and send them the NFTs for free</li> </ul> <p>Cons of such scenario:</p> <ul>   <li>some general cons from the previous scenarios</li>   <li>basically, no additional cons if you are using it properly</li> </ul> <h3>A little bit of everything type scenario</h3> <p>In the last section of this article, I would like to focus on a custom scenario with which I would probably go.</p> <p>For example, purposes let's say I have a collection of 3333 NFTs.</p> <p>Let's start with a 'giveaway' process. I would probably prepare a list of addresses of people I want to thank. It could be a designer, or developer, or my friend. I would probably do this before even starting the whole process. Let's say I want to give 33 tokens at the beginning. I would use the <code>elven-tools nft-minter giveaway</code> command. So, now I have 3300 tokens left. I can check that using the query <code>elven-tools nft-minter get-total-tokens-left</code> can be run by everyone, not only by the owner of the Smart Contract.</p> <p>The following step would be to prepare the 'allowlist'. I could get addresses from closed discord groups or Twitter, competitions, and lotteries. Preparation of such a list would probably take some time, so I could also prepare some marketing and social media communication. I can populate the Smart Contract storage with addresses when the list is ready. I would use the <code>elven-tools nft-minter populate-allowlist</code>.</p> <p>I will prepare the drop to be adequate to the 'allowlist' addresses when the list is in place. So, for example, if I would like to have three tokens per address per drop, and my 'allowlist' has 100 addresses, I would set the drop to 300 tokens max.</p> <div class=\"docs-info-box\"><strong>Important!</strong> The first version of the allowlist is not clearable. All added addresses will always stay there until minting the whole collection. So be careful with drops and allowlist. I recommend adding only one allowlist without drops and waiting till all addresses are claimed or till the allowlist is disabled, or creating only one allowlist for the first drop.</div> <div class=\"docs-info-box\"><strong>Important</strong> Also, please remember that each drop can have its limits per address, but a single address won't be able to mint more than the overall limit per token per the whole collection even if there is still room for that in current drop. Always be careful and plan it that way that everything sums up. You can change the global limit per address by: `elven-tools nft-minter set-new-tokens-limit-per-address`.</div> <p>Let's go back to our custom scenario. So when you have the drop set to 300 tokens, we can set up the price. It will probably be something low as for the start and allowlist. You can do this by: <code>elven-tools nft-minter set-new-price</code>.</p> <p>Then we can start the minting for only eligible addresses from the allowlist. All other attempts will fail. You can always check how many tokens are left by: <code>elven-tools nft-minter get-drop-tokens-left</code>. The Smart Contract will pause the minting process when all 300 tokens are minted.</p> <p>When all tokens from the first drop are minted, I will prepare all the marketing for the next drop. I would probably not reveal the price yet. I would like to know what is happening with the first 333 tokens on the secondary market. What is the price, etc.? I would probably plan the next giveaway. Let's say I would give 100 tokens. Then I would prepare the next drop. Now I have 2900, so I would probably go with 2000 and 900 drop. You need to repeat the steps. Remember always to look out in which state the Smart Contract is. Remember about changing prices, and adequately stop and start minting.</p> <div class=\"docs-info-box\">Please keep in mind that this is a quick idea for example purposes. Do it as you think it will be best for your project. It is all quite elastic.</div> <h3>Summary</h3> <p>Here are a couple of ideas on preparing the Smart Contract to sell the NFT collection on the Elrond blockchain.</p> <p>Hopefully, it will be helpful, and the examples will help better understand the idea behind all the existing endpoints on the Smart Contract.</p> <p>There will probably be more improvements. Please let me know if you will find a bug or have some ideas to improve the toolset. You can write to me directly: <a href=\"https://twitter.com/JulianCwirko\">Twitter</a> and <a href=\"https://t.me/JulianCwirko\">Telegram</a>. Or you can report an issue on GitHub for the Smart Contract <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/issues\">here</a> and the CLI <a href=\"https://github.com/ElvenTools/elven-tools-cli/issues\">here</a>.</p>","excerpt":"How exactly should one work with the Elven Tools? Let's see the options on how you could randomly mint and distribute your NFTs","publicationDate":"2022-01-25","tags":["articles"],"coverImage":""},{"fileName":"jump-start.html","title":"Jump start","body":"<div class=\"docs-info-box\">It has complete functionality for the first version, but it is still under active development. As for the mainnet, use it at your own risk! Test it first on the devnet/testnet. Please report all the <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/issues\" class=\"common-link\">issues and ideas</a>.</div> <div class=\"docs-info-box\">Remember that the CLI uses public API endpoints by default. You can switch to the custom ones. Read more how to do this <a href=\"/docs/recipes.html#custom-api-endpoints\">here</a>.</div> <h3>TL;DR</h3> <ol>   <li><code>npm install -g elven-tools</code> -> install the npm library (you would need to have Node configured on the system)</li>   <li><code>elven-tools derive-pem</code> -> provide the seed phrase, the walletKey.pem file will be generated</li>   <li><code>elven-tools deploy nft-minter</code> -> provide all the data. There will be a couple of prompts</li>   <li><code>elven-tools nft-minter issue-collection-token</code> -> provide the name and ticker, be careful. They should be short. The ticker should be capitalized</li>   <li><code>elven-tools nft-minter set-roles</code> -> roles for the issued token</li>   <li><code>elven-tools nft-minter shuffle</code> -> this one should be called at least one. It can be called at any time by anyone</li>   <li><code>elven-tools nft-minter start-minting</code> -> starts the minting. By default, it is paused at start</li>   <li><code>elven-tools nft-minter mint</code> -> mint tokens, provide the amount, be careful. There will be custom limits per address</li> </ol> <p>There is also a video which shows it. So I recommend you to check it out:</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/resGP6a7_34\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>Longer step-by-step guides</h3> <p>The Elven Tools includes the Smart Contract, CLI tool, and Landing page for NFT launches. Every part of it can be used as a separate tool. But the best is to use it all together. You can, of course, use the Smart Contract separately using, for example, erdpy, but the elven-tools cli gives you a lot of simplification with the process. You don't have to think about proper arguments because it will ask you for them. Let's see what the workflow could look like.</p> <p>Let's say that you want to prepare a collection generated randomly from .png layers. You can do this with many tools on the Internet. Btw, please take a look at my <a href=\"https://github.com/juliancwirko/nft-art-maker\">custom solution</a>.</p> <p>In the end, you will have a set of generated images and metadata JSON files corresponding to each. It can look like <code>1.png</code> and <code>1.json</code>. Then you would need to pack them and upload them to the IPFS. The IPFS is the only recommended decentralized hosting on the Elrond chain, at least for now. You can upload the files using for example the <a href=\"https://www.pinata.cloud/\">Pinata</a> or <a href=\"https://nft.storage/\">NFT.storage</a>. When you do that, you will get the CIDs, a <a href=\"https://docs.ipfs.io/concepts/content-addressing/\">content identifier</a> for your assets. With that, we can start using the elven-tools cli. Let's jump to it right now.</p> <p>First of all, you would need to install it globally. You need to set up the <a href=\"https://nodejs.org/en/\">Node</a> environment. The npm tool should be included. Then you would need to install the elven-tools CLI. You can do this by: <code>npm install -g elven-tools</code>.</p> <p>By default, the elven-tools cli will come with pre-configured options. The most important is the chain on which it works. It is set to the 'devnet' and the source of the minter Smart Contract. It is set to the 'main' branch of <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">this</a> repo. So in simple words, you don't have to do any configuration to start with the nft minter Smart Contract on the devnet. I'll show you how to configure it for the other setup later.</p> <p>Let's focus on the devnet and the Smart Contract code from a remote source.</p> <p>What you need to do to start is to run the <code>elven-tools derive-pem</code>. You should have the elven-tools cli installed globally so accessible from everywhere in your env. The best would be to create a separate directory to work with it.</p> <pre><code class=\"language-bash\">elven-tools derive-pem âœ” Enter mnemonic (seed phrase)  â€¦ source crop brown mountain grace imitate cattle rice profit truck small soul castle prize tube spoil such topic code actor venue friend truck alien File saved as walletKey.pem </code></pre> <p>Derive PEM is a command which will take your seed phrase and create the key file for signing every transaction. Without it, you won't be able to use the elven-tools cli. The good thing is that you will need to do this only once. And then run every command in the same directory where the <code>walletKey.pem</code> file will land after running this command.</p> <div class=\"docs-error-box\">Don't share your PEM file with anyone. It is the main key to your walletâ€”the same as the seed phrases. The elven-tools don't send any data to the Internet. It works with it only in your local file system.</div> <p>After you generate the PEM file, you can run all other commands. Let's walk through the whole process here.</p> <p>The first command will be <code>elven-tools deploy nft-minter</code>. It takes the Smart Contract code from its repository and tries to deploy it on behalf of the user whose walletKey.pem file is generated in this directory. It will ask a couple of questions. Let's explain them here.</p> <p>When deploying using the CLI tool, it will also trigger the <code>populateIndexes</code> transactions, depending on the amount of the tokens provided. You can also call it by hand if something goes wrong. Always check the transactions after deployment on the Elrond explorer. This operation is mandatory, so if you don't use the CLI you would need to do it by yourself.</p> <pre><code class=\"language-bash\">elven-tools deploy nft-minter âœ” Decide if the contract can be upgraded in the future.  â€º Yes âœ” Decide if the contracts storage can be read by other contracts. Not recommended in this case.  â€º No âœ” Decide if the contract can receive funds. Recommended because of the royalties.  â€º Yes âœ” Provide the base IPFS CID:  â€¦ main_asset_ipfs_cid_here âœ” Provide the base metadata files IPFS CID:  â€¦ main_metadata_ipfs_cid_here âœ” Do you want to attach the metadata JSON file in the Assets/Uris?   (It will be attached and encoded in the attributes anyway, but some marketplaces require that).   â€º Yes âœ” Provide the file extension:  â€º .png âœ” Provide amount of tokens in collection:  â€¦ 10000 âœ” Provide the seling price (ex. 0.5 for 0.5 EGLD):  â€¦ 0.01 âœ” Total tokens limit per one address per whole collection:  â€¦ 6 âœ” Provide the royalties value (ex. 20 for 20%) [optional]:  â€¦ 5 âœ” Provide tags (ex. tag1,tag2,tag3) [optional]:  â€¦ test1,test2 âœ” Provide the provenance hash (sha256 hash of all images) [optional]:  â€¦ optional_provenance_hash_here Deployment transaction executed: success Deployment tx: https://devnet-explorer.elrond.com/transactions/6c78b4f9adbf4e04e84e5ffe8bfed577ee2ad080c039fb3c3db1199c5d1d413c Populating indexes transaction executed! Populate indexes tx (1): https://devnet-explorer.elrond.com/transactions/284addb23c3d6ec4809fcca1394a5827574aaf68397e0baf703c718c6319bd7a Populating indexes transaction executed! Populate indexes tx (2): https://devnet-explorer.elrond.com/transactions/254793bd5a005548f234d4efda54313fd8079e834ac9fe679f124d0a1bcf6a9b Smart Contract address: erd1qqqqqqqqqqqqqpgqetmlnt8t8u9nll6l87we9wsp60m602pselesmc86cg </code></pre> <p>You will be asked one by one. The prompts are helpful. You don't have to worry about proper arguments preparation. The first three questions are about metadata for code. You need to decide if your smart contract should be payable or upgradable. There are hints for that. You can also read about it <a href=\"https://docs.elrond.com/developers/developer-reference/code-metadata/\">here</a>.</p> <p>The following prompt is where you would need to provide your CIDs. It can be a different CID for metadata and images, but it can also be the same CID. It depends on how you store your files in the IPFS.</p> <p>You will also be able to choose if you want your metadata file to be attached in the Assets/Uris next to the Uri for the asset file (like .png). The metadata Uri is encoded in the attributes, but some marketplaces also require it in the Uris array.</p> <p>Then you can also configure the file extension. There are a couple to choose from.</p> <p>After that, you will provide the total amount of tokens in your collection.</p> <p>Next is the selling price. You can use the standard format here. For example, 0.5 is 0.5 EGLD.</p> <p>Then you would need to define how many tokens one address can mint. It is usually used to prevent a big player from buying the almost whole collection. Of course, it doesn't avoid minting on the different addresses, but it is always helpful.</p> <p>Then you can provide the royalties value. Use standard percent here, so 5 is a 5%.</p> <p>Then you can give the tags for the collection, and at the end, you can also provide the <a href=\"https://medium.com/coinmonks/the-elegance-of-the-nft-provenance-hash-solution-823b39f99473\">provenance hash</a>. It will also be queryable later.</p> <p>The following mandatory command which you would use is issuing the collection token. You can do this by running <code>elven-tools nft-minter issue-collection-token</code>. The token will be issued, and all will be saved in the <code>output.json</code> file in the same directory. Here you will be asked about the name of the collection and the ticker. It looks like that:</p> <pre><code class=\"language-bash\">elven-tools nft-minter issue-collection-token âœ” Enter the name for the collection token (ex. MyName123).  Avoid spaces and special characters  â€¦ TestCollectionName âœ” Enter the ticker for the collection token (ex. MYNAME).  Avoid spaces and special characters. Keep it short and capitalize.  â€¦ TCLN â ¼ Processing transaction... Transaction: https://devnet-explorer.elrond.com/transactions/762adbb2485697c5b20a09ca28ff6bd4f0b11238ce57bee99d24c8ebd7a1d826 Your collection token id:  TCLN-416d0e Also saved in the output.json file. </code></pre> <p>The last mandatory command is <code>elven-tools nft-minter set-roles</code>. It will assign the obligatory role, which allows for new NFT tokens creation. Here there won't be any prompts, at least for now. Only a transaction will take the token data from the output.json file and assign the roles.</p> <pre><code class=\"language-bash\">elven-tools nft-minter set-roles Transaction: https://devnet-explorer.elrond.com/transactions/b156ebc9f91a75c56ee5e1ae034c2e4ce09a9de16cde79f297221b457902e326 </code></pre> <p>You would also need to call the <code>elven-tools nft-minter shuffle</code> at least once. This one is accessible for everyone. Everyone can call it to change the following index, which will be minted without knowing precisely what it will be.</p> <pre><code class=\"language-bash\">elven-tools nft-minter shuffle Transaction: https://devnet-explorer.elrond.com/transactions/c9248963f37e95ce81e58b06a6a8edc2872f48919302ca8d2914dcf3107aac19 </code></pre> <p>The following steps can be different on what you want to achieve. You can start minting directly or set up so-called 'drops' where you will define how many tokens will be minted in one drop. You can also always start or pause the minting process. What is necessary is that the contract will always mint randomly in all cases. Let's see how it looks when we want just to start the minting: <code>elven-tools nft-minter start-minting</code> and <code>elven-tools nft-minter mint</code> You will be asked to provide how many tokens you would wish to mint. Remember that the Smart Contract will have limits per one address. See how to check them later in this article.</p> <pre><code class=\"language-bash\">elven-tools nft-minter start-minting âœ” Are you sure that you want to proceed?  â€º Yes â ¼ Processing transaction... Transaction: https://devnet-explorer.elrond.com/transactions/8260437c4a2296169cf7bd925f135223529029ad8e1b3f2b535ee7f07ef3672c  elven-tools nft-minter mint âœ” Provide how many tokens should be minted. Take into account possible limitations set on the Smart Contract (ex 3 for three tokens):  â€¦ 2 âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/15194f779bebc31babdc7711f685a4bf0560c9a0484f6e644a40a1a0ee2f94ef </code></pre> <p>Check out examples of scenarios with all that possibilities: <a href=\"/docs/elven-tools-workflows.html\">Elven Tools workflows</a>.</p> <h3>Good to know</h3> <p>The Elven Tools CLI can list all the available commands for every subcommand. You can do: <code>elven-tools --help</code> or <code>elven-tools nft-minter --help</code>. You can always check the installed version by <code>elven-tools --version</code>.</p> <p>Every step will update the <code>output.json</code> file. So, for example, the Smart Contract address will be put there and the collection token ticker. If you already deployed the Smart Contract without using the Elven Tools CLI, you can always configure it in the <code>.elventoolsrc</code> file using the config: <code>{ \"nftMinterSc\": { \"deployNftMinterSC\": \"&#x3C;sc_address_here>\" } }</code>.</p> <p>Not all the commands trigger a Smart Contract transaction. There are also public queries for the Smart Contract, for example:</p> <pre><code class=\"language-bash\">get-total-tokens-left get-provenance-hash get-drop-tokens-left get-nft-price get-nft-token-id get-nft-token-name get-tokens-limit-per-address-total get-tokens-minted-per-address-total get-tokens-limit-per-address-per-drop get-minted-per-address-per-drop </code></pre> <p>...and more, check <code>elven-tools nft-minter --help</code> for the whole list.</p> <p>With them, you can get simple information written in the Smart Contract. You can also access them through API. Read more about it <a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/virtual-machine/\">here</a>.</p> <p>Elven Tools will also provide the landing page for the NFT launch, which will be strictly integrated with the Smart Contract. It will have a lot of useful widgets. There are also plans to write more articles on how to run it with the performance in mind. It will come later.</p> <h3>Where to go from here?</h3> <p>This part of the docs had one purpose: to guide you through the process step by step.</p> <p>From here you can read more detailed docs on:</p> <ul>   <li><a href=\"/docs/recipes.html\">Recipes</a></li>   <li><a href=\"/docs/cli-introduction.html#custom-configuration-options\">CLI configuration options</a></li>   <li><a href=\"/docs/cli-commands.html\">CLI possible commands</a></li>   <li><a href=\"/docs/sc-endpoints.html\">Smart Contract endpoints</a></li> </ul> <p>If you still don't know how to use it, please feel free to contact me on <a href=\"https://twitter.com/JulianCwirko\">Twitter</a> or <a href=\"https://t.me/juliancwirko\">Telegram</a>. You can also write an e-mail to me: julian.cwirko@gmail.com</p>","excerpt":"The Elven Tools includes the Smart Contract, CLI tool, and Landing page for NFT launches. Every part of it can be used as a separate tool.","publicationDate":"2022-01-25","tags":["intro"],"coverImage":""},{"fileName":"landing-page.html","title":"Landing page","body":"<p>Landing page based on the <a href=\"https://nextjs.org/\">Next</a> framework.</p> <div class=\"docs-info-box\">The landing page template is still in progress. ETA: 04 Apr 2022!</div> <h3>Why Next?</h3> <p>There are a couple of reasons, the most important are:</p> <ol>   <li>Based on React, which is well known and most popular</li>   <li>Offers static sites generation or/and server-side rendering. Very important when it comes to landing pages and SEO.</li>   <li>Optimized with the Web Standards in mind. There are many tools for optimizing the assets loading and overall performance.</li>   <li>Simple PWA and Service Workers configuration is essential for optimization.</li>   <li>A lot of plugins and excellent development experience.</li> </ol> <h3>What will you get?</h3> <ol>   <li>Fully functional and optimized template to be used with the Next framework</li>   <li>Widgets, which will be used to make transactions and display collection-related information.</li>   <li>Guides on optimizing the website to avoid common performance problems using the official gateway and APIs.</li>   <li>Later, more advanced tools and guides on the blockchain interactions and the performance.</li> </ol> <h3>Stay tuned!</h3>","excerpt":"Fully functional and optimized template to be used with the Next framework.","publicationDate":"2022-01-25","tags":["landing page"],"coverImage":""},{"fileName":"recipes.html","title":"Recipes","body":"<p>Here are ready-to-use recipes and more information on real-life use cases.</p> <h3>How to work with the Smart Contract locally</h3> <p>In most cases, it is good to provide some modifications for the final version of the Smart Contract, such as changing the functions' names to make life harder for the bot's owners.</p> <p>It is good to build the Smart Contract locally and deploy it from the file system in such a case. It is possible by default with the Elven Tools CLI. You need to prepare the directory <code>sc/nft-minter</code> in the same place where you already have the <code>walletKey.pem</code> file and later the <code>output.json</code> file. The tree should look like that:</p> <pre><code class=\"language-bash\">. â”œâ”€â”€ output.json â”œâ”€â”€ sc â”‚   â””â”€â”€ nft-minter â”‚       â”œâ”€â”€ elven-nft-minter.abi.json â”‚       â””â”€â”€ elven-nft-minter.wasm â”œâ”€â”€ walletKey.pem </code></pre> <p>As you can see, we have the <code>.abi.json</code> and <code>.wasm</code> files there. You will find them in the <code>output</code> directory after building the Smart Contract locally, and the elven-tools cli tool will take them by default. Remember to only keep the same naming convention for the directories - <code>sc/nft-minter</code>.</p> <p>If you need some help working with the Smart Contract in the Elrond ecosystem, please check docs and my article <a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">here</a>.</p> <h3>How to use the configuration file</h3> <p>The configuration file is optional, and you don't need it until you want to change the chain or the Smart Contract source. Plus, maybe after some modifications, you would like to change the functions names and gas limit. All default values are defined <a href=\"https://github.com/ElvenTools/elven-tools-cli/blob/main/src/config.ts\">here</a>, and below, you'll find the example of how to overwrite them from outside of the lib itself.</p> <p>The configuration file should be named <code>.elventoolsrc,</code> or take any compatible name from the <a href=\"https://github.com/davidtheclark/cosmiconfig\">cosmiconfig</a> project. The main handle should be <code>elventools</code>.</p> <pre><code class=\"language-json\">{     \"chain\": \"testnet\",     \"nftMinterSc\": {         \"version\": \"v1.2.0\",         \"mintFnName\": \"mintMe\"     } } </code></pre> <p>In the example above, we define the chain as the 'testnet' (devnet is set by default), and we also define the version for the Smart Contract, <code>v1.2.0</code> (the last tag name should always be selected as default). It can also be a branch name. Then we also define the new name for the 'mint' function. You can also change names for other functions and set up different gas limits.</p> <p><strong>You will find all possible options <a href=\"/docs/cli-introduction.html#custom-configuration-options\">here</a>.</strong></p> <p>Remember, you don't have to change the <code>config.ts</code> file. It is for library usage. You don't have to clone the repository to change the configuration. <code>.elventoolsrc</code> is the only config file that should be used.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/UlyTVa6oLuM\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>Mainnet deployments</h3> <p><strong>Important!</strong> The same way as in the example above, you can configure deployment to <code>mainnet</code>. I don't recommend it yet, but if you know what you are doing, then remember about a couple of things:</p> <ul>   <li>make sure that you derive the walletKey.pem file from the seed from the mainnet wallet. Make sure that the computer you are using is safe, and no one will take the PEM file from you. Or/and seed phrase,</li>   <li>change the <code>chain</code> in the config file to the <code>mainnet</code>,</li>   <li>be careful with Smart Contract versions. By default, the latest version of the CLI will use the newest version of the Smart Contract. Remember that if you have .wasm and .abi files in the <code>sc/nft-minter</code> directory, then they will be used instead of the ones from the repository,</li>   <li>test the whole process 'million' times on the devnet, test with small amounts and big amounts, with multiple wallets as buyers, test queries and transactions, buy to the limits, to test them too,</li>   <li><strong>I can't provide individual support</strong>, but I will always try to help</li> </ul> <h3>Custom API endpoints</h3> <p>It is always advisable to use the custom API endpoints custom proxies for production-ready apps. Even with this tool, it is better to use the custom one. You can read more about how to set up your architecture <a href=\"https://docs.elrond.com/integrators/observing-squad/\">here</a>.</p> <p>Suppose you don't have the resources to do that. You can find third-party services which do that as a service.</p> <p>To switch to your custom API endpoint, you would need to add in your <code>.elventoolsrc</code> configuration file:</p> <pre><code>{   \"chain\": \"devnet\",   \"customProxyGateway\": \"https://devnet-api.elrond.com\" } </code></pre> <p>Here is an example with the default API endpoint for the devnet. You can do the same for the testnet and mainnet.</p> <h3>How to use allowlist</h3> <p>The allowlist is usually required for the first batch of tokens to distribute them only to chosen addresses. It can be a list of eligible addresses.</p> <p>There are three endpoints and commands which help with that. First you would need to have the listof addresses.</p> <p>Then you need a file called <code>allowlist.json</code> in the <code>sc/nft-minter</code> directory. It should have the list of addresses in such a form:</p> <pre><code class=\"language-json\">[   \"erd1.......\",   \"erd1.......\",   \"erd1.......\",   \"erd1.......\", ] </code></pre> <p>There should be a maximum of 250 addresses per transaction. You can make a couple of transactions if you need to. But remember to update the file on each.</p> <p>You can populate the list without the file, then the CLI will request it through a prompt where you need to provide them one by one, separated using a comma.</p> <p>Let's see what it looks like in both cases:</p> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter populate-allowlist   Populating addresses from the file: sc/nft-minter/allowlist.json   âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/4a3b63edc1cf00c8025c025926db033964e4625fa5ddcd316b880787f3c8094f </code></pre> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter populate-allowlist   There is no file with the addresses here: sc/nft-minter/allowlist.json You will be providing addresses by hand.   âœ” Are you sure that you want to proceed?  â€º Yes âœ” Provide the list of addresses. Max 250 addresses per one transaction. You can add more by sending more transactions. Separate them with comma (\",\"):  â€¦ erd1puseeussfftajfj92ezqtfp0ca6u0s2thu7n64cyw6m37ef8dh0sekwt27, erd18yxxeuf2fkwlwgrnc3chjyf4gl3429qpp5fqynhzf2gn6hs3h8dqu7zt7n Transaction: https://devnet-explorer.elrond.com/transactions/f8bf7de010629e32008bebb1ba5681a008f23afaf949e0e565ea3bbf41bd80fd </code></pre> <p>Remember that you will always need to enable the allowlist after populating it. Otherwise, it will be ignored. You can enable and disable it using: <code>elven-tools nft-minter enable-allowlist</code> and <code>elven-tools nft-minter disable-allowlist</code>.</p> <p>You can also use a couple of SC queries. This allows to get the current size of the allowlist, check if the address is there, or check if the allowlist is enabled. These are:</p> <pre><code>elven-tools nft-minter get-allowlist-size elven-tools nft-minter is-allowlist-enabled elven-tools nft-minter get-allowlist-address-check </code></pre> <p>Remember that you can always use the functionality without using the CLI tool, then you would need to call the same endpoints. You will find all commands for the CLI <a href=\"/docs/cli-commands.html\">here</a> and all SC endpoints <a href=\"/docs/sc-endpoints.html\">here</a>. Also, check the longer article about <a href=\"/docs/elven-tools-workflows.html\">possible workflows</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rdg6s7KHFt0\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to use drops</h3> <p>The drops are, in simple words, batches of tokens to mint. You don't have to use them, but it is usually required because most projects usually split the collection into 'waves' of distribution.</p> <p>Now let's see how to define a drop in which we will mint only 2500 of the whole 10k collection. You would need to use <code>elven-tools nft-minter set-drop</code> when using the CLI tool. You will be asked to provide how many tokens per drop it should mint. After that, it will pause the minting process. You can also pause the minting at any time you want by <code>elven-tools nft-minter pause-minting</code>. You can also unset the drop by <code>elven-tools nft-minter unset-drop</code>. You'll find all the commands <a href=\"/docs/cli-commands.html\">here</a>.</p> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter set-drop âœ” Provide the amount of the tokens for the drop:  â€¦ 2500 Transaction: https://devnet-explorer.elrond.com/transactions/915a9b115d01dbc0026e91ab889284018bd51cee8a030804dbb5da600c1bdd25  elven-tools nft-minter mint âœ” Provide how many tokens should be minted. Take into account possible limitations set on the Smart Contract (ex 3 for three tokens):  â€¦ 2 âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/8954262fea15e63705d696fcfeb92874a4c10239703b5a6631fd7f989c494ba8 </code></pre> <p>There are also SC queries that allow checking a couple of things. These are:</p> <pre><code>elven-tools nft-minter get-drop-tokens-left elven-tools nft-minter get-minted-per-address-per-drop elven-tools nft-minter get-tokens-limit-per-address-per-drop elven-tools nft-minter is-drop-active </code></pre> <p>They are self-explanatory, but you will find all descriptions under the links below.</p> <p>Remember that you can always use the functionality without using the CLI tool, then you would need to call the same endpoints. You will find all commands for the CLI <a href=\"/docs/cli-commands.html\">here</a> and all SC endpoints <a href=\"/docs/sc-endpoints.html\">here</a>. Also, check the longer article about <a href=\"/docs/elven-tools-workflows.html\">possible workflows</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZERCb-c-BP4\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to use the giveaway</h3> <p>The <code>giveaway</code> functionality is helpful when you want to give some tokens to a particular address. It can be because they are the team members or someone you want to thank. Remember that with Elven Tools, you can choose the specific token. It will still be randomly selected and minted. When using this functionality, there is no paymentâ€”only transaction fees.</p> <p>You can give some tokens using the CLI's command <code>elven-tools nft-minter giveaway</code>. You would need to provide the address to which you would like to send the NFTs and the amount of the tokens to give.</p> <p>You can use this even when the minting process is paused, which is usable for the giveaway before the official minting is started.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/WH7kl3s7gdw\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to claim dev rewards</h3> <p>In the Elrond ecosystem, each Smart Contract will get the share of the fees as a development reward. So the developer of the contract will get some share because this is an open source Smart Contract. It will generate these rewards for everyone who deploys it. You can claim them by using: <code>elven-tools nft-minter claim-dev-rewards</code>. Remember that this will only work for the owner of the Smart Contract.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <h3>How to claim royalties and other funds</h3> <p>The Smart Contract is payable by default, so in theory, it is possible to transfer EGLD funds to its address. By definition, this is how marketplaces should send the royalties. There is an <code>elven-tools nft-minter claim-sc-funds</code>, which will allow getting all the funds locked on the contract. Of course, only for the owner of the contract.</p> <p>There will also be a dedicated endpoint/command which will call the marketplaces Smart Contracts to claim the royalties because not all of them will send them automatically.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <h3>How to get owners addresses using the collection ticker</h3> <p>From version 1.6.0 there is additional command <code>elven-tools collection-nft-owners</code>. It will allow getting owners' addresses, using only the collection ticker. It is useful, for example, when you want to do some promotional giveaway. The functionality will save the addresses in the <code>nft-collection-owners.json</code> where the command is triggered.</p> <p>For now, the functionality does only that. Maybe in the future, it will be extended.</p> <p>Important: It will work only with the API endpoint, not the gateway. Elven Tools CLI, by default, uses the API endpoint. So it should work by default, but you need to remember that.</p> <p>How to use it? You need to use at least version 1.6.0 of the CLI. You can check it by <code>elven-tools -v</code>, and you would need to use the command <code>elven-tools collection-nft-owners</code>. Then there are three prompts. You would need to provide the collection ticker and answer two questions about whether you want to filter not unique addresses and smart contract addresses.</p> <p>Because of how the API works, we need to do calls with a max size of 100 items. Here we also have calls that are limited to 5 per second. You can change this limit in the configuration file. Check how <a href=\"/docs/cli-introduction#custom-configuration-options\">here</a>. If you need to change this setting, in the config file, there should be an entry:</p> <pre><code>{   \"collectionNftOwners\": {     \"apiCallsPerSecond\": 5   } } </code></pre> <p>When is the address not unique? It is when one address will have more than one NFT token from the collection. See the example below:</p> <pre><code>elven-tools collection-nft-owners  âœ” Provide the collection ticker  â€¦ EAPES-8f3c1f âœ” Do you want to include only unique addresses?  â€º Yes âœ” Do you want to exclude smart contract addresses?  â€º Yes  There is 10000 tokens in that collection. Done, 1082 addresses saved. Only uniq addresses. Without smart contract addresses. </code></pre> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Li1Lf6h-ksU\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>CLI for a buyer</h3> <p>You can also use the CLI tool when you are only a buyer, not an owner of the Smart Contract. To do so, you would need to go through 4 steps.</p> <ol>   <li>Install the CLI: <code>npm install elven-tools -g</code></li>   <li>Derive the PEM file of your wallet: <code>elven-tools derive-pem</code> You would need to pass your seed phrase here. No worries, you work on your computer. If it is safe, nothing leaves it because of the CLI too. Never share seed phrases and PEM files with anyone.</li>   <li>Create a configuration file in the same directory as the generated walletKey.pem file. The configuration file should be named <code>.elventoolsrc</code>. Inside add:</li> </ol> <pre><code>{   \"nftMinterSc\": {     \"deployNftMinterSC\": \"&#x3C;nft_minter_smart_contract_address_here>\",     \"tokenSelingPrice\": \"&#x3C;price_of_the_nft_here>\"   } } </code></pre> <p>You would need only these two settings to be able to buy. Of course, the contract owner should prepare everything and start the minting process.</p> <p>   The <code>tokenSelingPrice</code> here is a format with 18 zeros. So 1 EGLD is 1000000000000000000.   The <code>deployNftMinterSC</code> here is an address of the contract. The owner should share it. </p> <ol start=\"4\">   <li>The last would be to call the mint command: <code>elven-tools nft-minter mint</code>. You will be asked about the number of tokens to mint. There will be limits. You would know them. You can <a href=\"/docs/sc-endpoints.html#smart-contract-queries\">query the contract to check them</a>.</li> </ol> <h3>What is an output.json file</h3> <p>The <code>output.json</code> file will be created as temporary storage, which keeps the created Smart Contract address, the information about the collection token, and the token price. It is required in further operations. This file is created automatically when deploying the Smart Contract using the CLI. So it is mostly there for the owner of the Smart Contract. It looks like that:</p> <pre><code class=\"language-json\">{   \"nftMinterScAddress\": \"erd1qqqqqqqqqqqqqpgq7a0cq90r2kqymtaqysxp7umrcyp04jgmgtkscelhmp\",   \"nftMinterScCollectionSellingPrice\": \"1000000000000000\" } </code></pre> <p>You don't have to think about it much.</p> <h3>Why do we need the populateIndexes endpoint</h3> <p>The endpoint is required for the initial setup of the Smart Contract. You don't have to think about it when you use the CLI. It will be automatically called when deploying the Smart Contract.</p> <p>Its task is to populate the VecMapper storage with the indexes. These indexes are used to handle the random minting process. Without them, it would be less performant to provide such functionality for many tokens.</p> <p>If you don't use the CLI, you need to perform this operation by hand after the Smart Contract is deployed. Remember that there will always be a limit per one transaction. You can check it in the <a href=\"https://github.com/ElvenTools/elven-tools-cli/blob/main/src/config.ts\">internal config file</a> search for <code>populateIndexesMaxBatchSize</code>. So basically, you would need to split the number of your tokens into more than one transaction if there is more of them than the limit.</p> <p>There is also a CLI command because sometimes, something may go wrong. So then you will need to run the <code>elven-tools nft-minter populate-indexes</code> and provide the number of tokens keeping in mind the limits per transaction.</p> <h3>Why do we need the shuffle endpoint</h3> <p>The endpoint will set the following index to mint. It is important here that it will randomly select it from the indexes left to mint. This endpoint is also public, so everyone can call the transaction and change the following index to mint. It assures that the process is random, and everyone can impact that.</p> <p>When using the CLI you can always run <code>elven-tools nft-minter shuffle</code>.</p>","excerpt":"The Elven Tools includes the Smart Contract, CLI tool, and Landing page for NFT launches. Every part of it can be used as a separate tool.","publicationDate":"2022-01-25","tags":["intro"],"coverImage":""},{"fileName":"sc-endpoints.html","title":"SC Endpoints","body":"<p>Below you'll find all endpoints with a short description. You can always see the complete code <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">here</a>.</p> <p>Please check all attributes for each endpoint in the linked code line in the repository. It is all open-source.</p> <p>You'll find all the endpoints here: <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/blob/main/src/lib.rs\">lib.rs</a>.</p> <h3>Setup endpoints</h3> <p>These are the required operations you would need to perform once always when configuring a new collection and Smart Contract. Check the CLI tool to simplify the work required.</p> <ul>   <li><code>init</code> - standard init endpoint, it will be triggered on deployment and upgrade</li>   <li><code>populateIndexes</code> - A very important endpoint. It populates the VecMapper with indexes to mint. You would need to split the number of total tokens provided when deploying the contract into batches of 2200 max. The split is required because of the max gas limits. When using the Elven Tools CLI, the usage of this endpoint will be hidden when deploying. It will be done automatically. You won't mint if the indexes are not correctly populated. This operation is done only once with the number of transactions depending on the total amount of tokens. This additional configuration step gives us a performant way of randomly minting because the base is a VecMapper, and we use <code>swap_remove</code> there. I found it the simplest and most performant way of doing that.</li>   <li><code>issueToken</code> - required endpoint for creating a new collection, this is done once, and the token is one for one smart contract instance. It is a handler for the whole collection.</li>   <li><code>setLocalRoles</code> - Set roles set only one role for now. The required one for creating the NFTs.</li>   <li><code>shuffle</code> - this one is not owner only because everyone can call it, but it is required to call it at least once to be able to start minting</li>   <li><code>startMinting</code> - You will need to start the minting process after deploying the contract and each time you use the pauseMinting function</li> </ul> <h3>Only owner endpoints</h3> <p>Only the owner of the Smart Contract can call them. In such a Smart Contract, there are quite a lot of them. Some of them are mandatory for the initial Smart Contract setup. See above. To keep everything in order, they are also copied here.</p> <ul>   <li><code>init</code> - standard init endpoint, it will be triggered on deployment and upgrade</li>   <li><code>populateIndexes</code> - A very important endpoint. It populates the VecMapper with indexes to mint. You would need to split the number of total tokens provided when deploying the contract into batches of 2200 max. The split is required because of the max gas limits. When using the Elven Tools CLI, the usage of this endpoint will be hidden when deploying. It will be done automatically. You won't mint if the indexes are not correctly populated. This operation is done only once with the number of transactions depending on the total amount of tokens. This additional configuration step gives us a performant way of randomly minting because the base is a VecMapper, and we use <code>swap_remove</code> there. I found it the simplest and most performant way of doing that.</li>   <li><code>issueToken</code> - required endpoint for creating a new collection, this is done once, and the token is one for one smart contract instance. It is a handler for the whole collection.</li>   <li><code>setLocalRoles</code> - Set roles set only one role for now. The required one for creating the NFTs.</li>   <li><code>pauseMinting</code> - You can pause the minting process in any moment you need.</li>   <li><code>startMinting</code> - You will need to start the minting process after deploying the contract and each time you use the pauseMinting function</li>   <li><code>setDrop</code> - You can set the 'drop' by defining how many tokens per drop will be minted</li>   <li><code>unsetDrop</code> - You can unset the drop in any time. Minting will continue without limits.</li>   <li><code>setNewPrice</code> - You can change the price for each NFT at any time. The best is to do this when configuring the next drop.</li>   <li><code>changeBaseCids</code> - You can change the CIDs for images and metadata, but only when there is no NFTs minted yet. Otherwise, it doesn't make sense because the collection will be unsynchronized.</li>   <li><code>setNewTokensLimitPerAddress</code> - You can change the limit of tokens per single address in any given time.</li>   <li><code>giveaway</code> - You can organize the giveaway by providing the address and amount of tokens to send. It will mint and send tokens without the payment.</li>   <li><code>claimScFunds</code> - You can claim the funds which are there on the payable Smart Contract. For example, royalties paid by marketplaces. These are only funds that come from outside. The funds from minting are directly sent to the contract owner after each mint.</li>   <li><code>populateAllowlist</code> - You can set up the allowlist by populating the storage with addresses. Keep 250 addresses as max per one transaction. Otherwise, it could reach the max gas limit.</li>   <li><code>enableAllowlist</code> - You can enable to allowlist. Only then will it work. Remember about that.</li>   <li><code>disableAllowlist</code> - Tou can disable the allowlist and keep standard minting functionality</li> </ul> <h3>Endpoints for all</h3> <ul>   <li><code>mint</code> - The main mint/buy function. The smart contract works like a candy machine. You pay, and it randomly mints the NFT for you. Then it sends it into your wallet. The NFTs on the Elrond network are ESDT standardized tokens.</li>   <li><code>shuffle</code> - To be more transparent, the Smart Contract has a public endpoint that allows everyone to trigger the shuffling mechanism which is also triggered after every mint. This additional functionality ensures that the process is random, and anyone can set the following index.</li> </ul> <h3>Smart Contract queries (also for all, by design)</h3> <ul>   <li><code>getDropTokensLeft</code> - This query will return the tokens left for the active drop.</li>   <li><code>getTotalTokensLeft</code> - This query will return total amount of tokens left to mint</li>   <li><code>getNftTokenId</code> - This query will return the collection token ticker</li>   <li><code>getNftTokenName</code> - This query will return the collection token name</li>   <li><code>getNftPrice</code> - This query will return the price for a single NFT</li>   <li><code>getTokensLimitPerAddressTotal</code> - This query will return the limit of tokens for a single address as total for the whole collection</li>   <li><code>getMintedPerAddressTotal</code> - This query will return tokens already minted per single address as total for the whole collection</li>   <li><code>getTokensLimitPerAddressPerDrop</code> - This query will return the limit of tokens for a single address per drop</li>   <li><code>getMintedPerAddressPerDrop</code> - This query will return tokens already minted per single address per drop</li>   <li><code>getProvenanceHash</code> - This query will show the provenance hash if provided.</li>   <li><code>getAllowlistAddressCheck</code> - This query will check if the provided address is on the allowlist.</li>   <li><code>getAllowlistSize</code> - This is mainly to check if the allowlist has the correct size after populating it with addresses.</li>   <li><code>isAllowlistEnabled</code> - This is an important check to ensure that the allowlist is enabled. Only then will it work.</li>   <li><code>isDropActive</code> - This is for checking if there is currently a drop active.</li> </ul> <h3>How to interact with endpoints</h3> <p>The simplest way is to use the Elven Tools CLI, check how in the <a href=\"/docs/jump-start.html\">Jump start</a> article or the <a href=\"/docs/cli-introduction.html\">CLI introduction</a>.</p> <p>If you don't want to use the CLI, you need to do the queries and transaction calls using the <a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs\">erdjs SDK</a> or <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy/\">erdpy</a>.</p> <p>Check the examples for <code>erdjs</code>:</p> <ul>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs#creating-smart-contract-transactions\">Smart Contract transaction</a></li>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs#querying-smart-contracts\">Smart Contract query</a></li> </ul> <p>There will be also fully functional landing page which will use it.</p> <p>You can also check the <a href=\"https://github.com/ElvenTools/elven-tools-cli\">elven-tools-cli</a> source code, where I also used the erdjs SDK.</p> <p>With the landing page, you will get all of these as components.</p> <p>Check the examples for <code>erdpy</code>:</p> <ul>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdpy/blob/main/erdpy/CLI.md\">Command Line Interface</a></li>   <li><a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">Blog post with usage examples</a></li> </ul>","excerpt":"Below you'll find all endpoints with a short description. You can always see the complete code.","publicationDate":"2022-01-24","tags":["smart contract"],"coverImage":""},{"fileName":"sc-introduction.html","title":"SC Introduction","body":"<p>NFT minter Smart Contract v1</p> <div class=\"docs-info-box\">Be aware that the Smart Contract doesn't have any audits. It has complete functionality for the first version, but it is still under active development. As for the mainnet, use it at your own risk! Test it first on the devnet/testnet.</div> <p>You are reading about the Smart Contract designed for the Elrond blockchain. Its primary purpose is to provide a simple logic for minting and buying NFT tokens from a previously configured collection. It does it in a randomized way.</p> <h3>Version 1 supports</h3> <ul>   <li>issuing the collection token</li>   <li>setting the create role</li>   <li>pausing/unpausing the process</li>   <li>random mint and distribution</li>   <li>minting multiple NFTs in one transaction</li>   <li>giveaway options</li>   <li>possibility to split the process into drops/waves</li>   <li>claiming the developer rewards</li>   <li>changing basic setup where it is possible</li> </ul> <p>The smart contract works like a candy machine. In short, the user can pay in EGLD and, in return, will get randomly minted tokens from the previously configured collection. The amount of tokens per address is configured on the smart contract.</p> <h3>Required initial configuration</h3> <p>All are mandatory operations and should be done only once. Make the transactions in this order.</p> <ol>   <li>The Smart Contract requires initial configuration to start the minting process. First, you would need to deploy it with all the arguments defined for the <code>init</code> endpoint. Check the description and link to the code in the <a href=\"/docs/sc-endpoints.html\">endpoints section</a>. It is simpler if you are using the <a href=\"/docs/cli-introduction.html\">Elven Tools CLI</a>.</li>   <li>If you are not using the CLI, you need to make a couple of transactions using the <code>populateIndexes</code> endpoint. The CLI does it automatically when deploying the Smart Contract.</li>   <li>You would need to issue the collection token using the <code>issueCollection</code> endpoint. With CLI, it is simpler to do that. Again, check it in the endpoints section.</li>   <li>Next is the <code>setLocalRoles</code> endpoint - it is required to set up proper roles for the collection token.</li>   <li>You would also need to run the <code>shuffle</code> endpoint at least once. This endpoint is public, and anyone can call it. Check more about it in the endpoints section.</li>   <li>Finally, you need to start the minting by calling the <code>startMinting</code> endpoint. By default, in the beginning, the minting is paused.</li> </ol> <p><strong>Remember that everything is more straightforward with the Elven Tools CLI</strong> Check the <a href=\"/docs/jump-start.html\">jump start section</a>.</p> <h3>Ways of using it</h3> <p>The best way of using it will be with <a href=\"/docs/cli-introduction.html\">Elven Tools CLI tool</a>. It has a lot of valuable functions integrated with the smart contract, so deploying or interacting is simple. You can deploy the smart contract directly from its repository. Almost no coding skills are required in this case.</p> <p>You can also take a more standard path and use <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy/\">erdpy</a> for that. Erdpy is an official CLI SDK for Elrond blockchain based on Python. For more information, check the <a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">blog post</a>.</p> <h3>Limitations and caveats</h3> <ul>   <li>Remember that it is most likely that because of the open-source nature of this Smart Contract, it won't be used only in a way that everyone would want to, be aware that you can always change the names of the endpoints in the Smart Contract. You can even deploy a couple of them. In the last minutes before the mint decide to use one of them. This will limit the bots. Remember always to inform which one is the official one.</li>   <li>Smart Contract in version 1 doesn't have many mechanisms which will strongly limit unwanted behaviors. It only implements random minting, but in version 2, there will be more mechanisms for fair launches.</li> </ul> <h3>Issues and ideas</h3> <p>Please post issues and ideas <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/issues\">here</a>.</p> <h3>Contact</h3> <ul>   <li><a href=\"https://t.me/juliancwirko\">Telegram</a></li>   <li><a href=\"https://twitter.com/JulianCwirko\">Twitter</a></li>   <li>julian.cwirko@gmail.com</li> </ul> <div class=\"next-page-link\">Next: <a href=\"/docs/sc-endpoints.html\">SC endpoints review</a></div>","excerpt":"You are reading about the Smart Contract designed for the Elrond blockchain. Its primary purpose is to provide a simple logic for minting and buying NFT tokens","publicationDate":"2022-01-25","tags":["smart contract"],"coverImage":""},{"fileName":"tips-on-buying-nfts-on-the-elrond-blockchain.html","title":"Tips on buying NFTs on the Elrond blockchain","body":"<p>There are a couple of things that you should check when you are buying the NFTs on the Elrond blockchain. And a couple of differences in comparison to other chains. I don't want to focus on the supply and demand aspect because you should always do your own research before buying anything. I want to focus on the technological and communication-like elements here.</p> <h3>What we will tackle in the article:</h3> <ol>   <li>Minting through the Smart Contract. How is it done?</li>   <li>The Smart Contracts on the Elrond blockchain are upgradeable by default.</li>   <li>Collection ticker and how to verify it.</li>   <li>Project website with the roadmap and people behind it.</li>   <li>Utility over 'art' unless not randomly generated.</li> </ol> <p>Remember, these are just my opinions. You can always disagree, and I will like to see your point of view.</p> <h3>Minting through the Smart Contract. How is it done?</h3> <p>Elrond blockchain treats the NFTs as native ESDT tokens with additional metadata, so it isn't required to have the Smart Contract to own them. And it isn't even needed to have a Smart Contract to mint them.</p> <p>Still, the minting process and distribution should be done using a Smart Contract because this is fair and trustworthy. The Smart Contract is a mediator between your EGLD and the NFT, which should be sent to you. Otherwise, some third-party wallet will be doing that, and in such a case, we need to trust the third party. So it is not a decentralized process.</p> <p>The best would be to see the Smart Contract's code or at least be able to verify if the Smart Contract is the official one. Most projects will probably not show the Smart Contract's source code, and I understand it. But still, I think it would be possible to prepare the hash of a currently compiled Smart Contract's code and publish it in all communication channels. This way, the user will also know if the contract was upgraded or not. And if the team communicated it properly before taking action.</p> <p>There are a couple of ways to prepare the minting and distribution process. All of them have pros and cons.</p> <p><strong>Let's take a look at two of them in the context of the Elrond blockchain:</strong></p> <ul>   <li>'Candy machine'</li>   <li>'Raffle'</li> </ul> <p>The candy machine's method of minting works like a candy machine (surprise, surprise). The Smart Contract is usually preconfigured to manage the minting process. The buyer sends the amount of EGLD defined on the Smart Contract, and in exchange, they will get randomly minted NFT on their wallet. It is a relatively straightforward way of doing that, and it is ok. Its main pros are simplicity and transparent rules, so the buyers are not confused. They pay, and they see it on the wallet. It is also simpler to set up and maintain, and because of randomization in the minting process, even with automated scripts, it will be hard to snipe the best NFTs. In most cases, this is the way the projects mint.</p> <p>The candy machine has its cons. The most important one is that when you want to mint in some batches spread in time, the first couple of NFTs will reveal the assets. At least in the Elrond ecosystem, it won't be possible to send the NFT and then change its assets URIs. The only option would be to upload the assets to the IPFS later, but this is a poor experience.</p> <p>Is it a big problem? Some would say that even better because these NFTs can influence the price, and with the second batch of minting, the operator will know better what a new price should be for the next official drop. If the first 1000 NFTs are doing great on the secondary market and the price is high. Then the subsequent official minting can be better marketed, and the price can be managed better.</p> <p>Other cons of the candy machine way of minting are that it is more prone to automated bots, and also, people from many different time zones will probably not have a chance to take part.</p> <p>There are a couple of solutions to these concerns. One would be not to send the tokens right away but to keep them and let the people claim them later after the whole collection is minted. Like with everything, this can be done with hybrid approaches, but most likely, it will be a Raffle minting process. Let's see how it could work on the Elrond blockchain and what the ideas are for it.</p> <p><strong>The Raffle can work in two ways:</strong></p> <ul>   <li>Locked EGLD as the ticket in a lottery</li>   <li>SFT (Semi Fungible Token) as the ticket in a lottery</li> </ul> <p>The simplest way would be to use EGLD and save all the addresses in the initial 'bidding/buying' phase. Such a phase can be spread in time. For example, it can be 48h long to allow all the people worldwide to participate. Then after some time, the operator can start the randomized claiming process, which will choose the winners. The winners will be able to claim the NFTs, and the losers will take back their EGLD.</p> <p>The problem of revealing the assets will still be here unless the Smart Contract will keep the winning tickets till the end of the minting of the whole collection. This can be done so that winning addresses are moved to allowlist, and losing addresses can claim back their EGLD immediately after each batch of minting.</p> <p>There is also a more entertaining way of doing that, incorporating the SFTs. Each SFT can look the same, for example, an egg for the dragons or a construction pack for robots, whatever you choose. Then each egg can be claimed after each batch of minting. So the winning addresses will also have something immediately, but not the real NFT yet. They can even sell these SFTs on the secondary market, similar to the candy machine incentive, but you don't operate on the real NFT.</p> <p>Why sell the SFT on the secondary market? Because the owner will be able to swap it for the real NFT when the time is right. Remember that the operator should also correctly communicate it.</p> <h3>The Smart Contracts on the Elrond blockchain are upgradeable by default.</h3> <p>It is worth mentioning that the Smart Contracts on the Elrond blockchain are by default upgradeable (and this is not only Elrond's specific case). What does it mean? It means that the operator can change the logic on the smart contract at every moment, even when the minting process is ongoing. In most cases, it is good because they will react quickly in case of bugs, and probably this is the way it will always work. But remember that it can also be used in a way that is not good for the participants. For example, some scam projects can release a proper Smart Contract, but then after the funds are on it, they can change its code and block all the funds.</p> <p>Ok, so what should you do with this kind of knowledge as a buyer? In most cases, projects won't show the Smart Contract's code anyway. So the best you can do is know about such possibilities and check how the project communicates them. Will they talk about changes or rather keep them in secret. It is why some kind of validation of the Smart Contracts is required, as I wrote before.</p> <p>What can the project do to gain more trust? I will write more about the community's communication later, but how it is appropriately managed is through multisig. So there should be more than one person on the team to be able to upgrade the contract. There should be a requirement for multiple keys to authorize such a transaction. But let's be honest, the minting Smart Contracts and projects around them are usually relatively small, and probably no one will use that. Still, it is worth knowing about it, and it will be a perfect point in the marketing of a project.</p> <p>How to check if a Smart Contract is upgradable or not? When you go to the Elrond Explorer and search for the project's Smart Contract, you will be able to see a badge. For example, let's take randomly one of the Smart Contracts on the mainnet: <a href=\"https://explorer.elrond.com/accounts/erd1qqqqqqqqqqqqqpgqxwakt2g7u9atsnr03gqcgmhcv38pt7mkd94q6shuwt\">explorer.elrond.com/accounts/erd1qqqqqqqqqqqqqpgqxwakt2g7u9atsnr03gqcgmhcv38pt7mkd94q6shuwt</a>. There is a badge <code>UPGRADEABLE</code> under the properties section.</p> <h3>Collection ticker and how to verify it.</h3> <p>On the Elrond blockchain, you would need to issue a collection token with a ticker in a short format, such as <code>ABCD-1a2e3</code>. It is an identifier for the NFT collection. For example, you can always check it in the Elrond Explorer, <a href=\"https://explorer.elrond.com/collections/EGIRL-443b95\">explorer.elrond.com/collections/EGIRL-443b95</a>.</p> <p>What is important here is that the project should always clearly communicate the official and only legit collection ticker. Because many scams will try to copy the collection, educating the buyers about that is always essential.</p> <p>   How will I check the collection ticker when I only have one NFT in my wallet?   Each NFT will get a ticker that starts with the collection id first. So in the case of our example from above, the <code>EGIRL-443b95-0d8b</code> is a particular NFT ticker/id, so as you can see, the <code>EGIRL-443b95</code> prefix here is our collection id from the example. This way, you can always verify if this particular NFT comes from an actual collection and not a scammy one. </p> <h3>Project website with the roadmap and people behind it.</h3> <p>Let's get into less technical and more communication-related topics. What is essential for me when I see the project is its website. It should be clean with good UI, and what is most important is that it should clearly describe the team and the vision. Most of the projects have only the Discord channel, but I don't find it professional. It is, of course, only my opinion and of course, having the Discord server isn't bad at all.</p> <p>When I enter such a website, I would like to see the official collection ticker/id and the Smart Contract address. Of course, it isn't always possible because it depends on the process. Maybe there isn't a collection and Smart Contract yet, but I would like to get it when the process starts.</p> <p>The team and roadmap are also critical. I saw that there are usually team members listed but nothing about them. They are just avatars with some nicknames. I think it is terrible, but of course, it is always good to be anonymous and earn some money ;)</p> <h3>Utility over 'art' unless not randomly generated.</h3> <p>I am not an artist, and I know nothing about art. But when we talk about randomly generated NFTs, it is for sure not about the art. I mean, maybe it is in some rare cases, but let's be honest, most of them are not even pretty ;)</p> <p>It is not a problem at all because, in my opinion, it isn't their primary purpose. Knowing something more than the price is good if you want to get involved in a randomly generated avatar-like collection. There should be a utility to having such an NFT in your wallet. There are a couple of such use cases. Let's list a couple of them in general without specific examples and descriptions. You will find a lot about them on the Internet:</p> <ul>   <li>NFT projects for the e-commerce industry.</li>   <li>NFT projects for the gaming industry.</li>   <li>NFT projects for the music industry.</li>   <li>NFT projects for the medical industry.</li>   <li>NFT projects for the real estate industry.</li>   <li>NFT for academics and schools.</li>   <li>NFT projects involved in charity.</li>   <li>NFT projects for the VR/Metaverse.</li>   <li>NFT as tickets.</li>   <li>NFT in sports.</li>   <li>NFT as the id and community platform access.</li> </ul> <p>The list can probably go a lot further. There are many use cases, but we are all early, and it has to settle down a little bit. I intend to indicate that you should always look deeper and buy some good projects. Unless you are an NFT flipper, then buy everything as fast as you can ;) But I am not interested in such an activity.</p> <h3>Summary</h3> <p>Hopefully, I explained a couple of the most important things when someone is interested in some NFT project on the Elrond Blockchain, but not only on the Elrond. Some of the guides are pretty universal.</p> <p>Be aware that these are only my opinions. I am primarily a developer, so I'm not an expert in marketing, selling, and promoting stuff. I wrote from a developer's perspective and a person who would like to buy some NFTs at some moment in time.</p> <p>   <a href=\"/about.html\">Contact me!</a>   Follow me on <a href=\"https://github.com/juliancwirko\">GitHub</a> and <a href=\"https://twitter.com/JulianCwirko\">Twitter</a>. </p>","excerpt":"There are a couple of things that you should check when you are buying the NFTs on the Elrond blockchain. And a couple of differences in comparison with other chains.","publicationDate":"2022-01-25","tags":["articles"],"coverImage":""},{"fileName":"use-of-ipfs-in-the-elrond-nft-ecosystem.html","title":"Use of IPFS in the Elrond NFT ecosystem","body":"<p>IPFS storage is a crucial part of every NFT ecosystem, not only the Elrond. I found that there is a lot of misunderstanding about why it is required and how it works. I won't describe the IPFS in detail, and it doesn't make sense because there are many excellent articles about it on the Internet that I am about to link. What I would like to do is to explain the basics in the context of Elrond NFTs.</p> <h3>What we will tackle here:</h3> <ul>   <li>IPFS basic intro.     <ul>       <li>Why is IPFS required?</li>       <li>How are the files handled?</li>       <li>What is a CID?</li>       <li>Pinning, why it is essential?</li>       <li>What is an IPFS gateway?</li>       <li>Where can I learn more about IPFS?</li>     </ul>   </li>   <li>How is it used in the Elrond ecosystem?</li>   <li>Helpful IPFS services and tools.</li> </ul> <h3>IPFS basic intro.</h3> <p>The InterPlanetary File System is a peer-to-peer hypermedia protocol. It allows storing and accessing data in a decentralized and trustless way. You are the owner of your data stored on many different nodes located in various places in the world. It can be an image, website, or any other data.</p> <p><strong>Why is IPFS required?</strong></p> <p>It is essential to have decentralized storage for the assets of your NFT token. The assets can't be stored on-chain for the main reason: the size and cost of keeping it on-chain. When using IPFS, you are not dependent on centralized corporations like Amazon, Microsoft, or Google to store your assets (images, movies, music). You don't want your NFT token to depend on a third-party company, even if it is only assets hosting. On-chain metadata, plus assets hosted in a decentralized way, seems like an obvious way of doing that.</p> <p><strong>How are the files handled?</strong></p> <p>One of the main concepts of the IPFS is content addressing. In the IPFS network, the identifier of the content is built based on the content, not the location. You can't change the address of the same content. It is possible, for example, using AWS, where you can change addresses to the same content by changing the domain name, etc. We don't want that for our NFTs because someone could move the assets somewhere else and change the address to them. Then the metadata information on-chain would be wrong, and the saved URL would not show the asset.</p> <p>When someone changes the content on the IPFS, it will get a different identifier and, in fact, always a different address. The old content can't be changed, deleted, or moved. So this is ideal. Our saved URL on-chain will always point to the same asset on the IPFS.</p> <p>You can learn a lot more about the topic here:</p> <ul>   <li><a href=\"https://proto.school/content-addressing\">proto.school/content-addressing</a>.</li>   <li><a href=\"https://docs.ipfs.io/concepts/how-ipfs-works/#content-addressing\">docs.ipfs.io/concepts/how-ipfs-works/#content-addressing</a></li> </ul> <p>Ok, so how the address/url to such content looks. Let's jump to the next topic from the list.</p> <p><strong>What is a CID?</strong></p> <p>The CID (Content Identifier) is a foundation of the content address on the IPFS. It doesn't tell where the content is located, but it defines the content. For example, it could be built based on one image or the directory of images. The main concept is that the CID will be different when anything is changed.</p> <p>The final CID form depends on the content and not on its size. It is a cryptographic hash of the content. The CID helps to find the nearest source of our content. This way, we will be able to get it from one of many nodes/peers in the network which could store it.</p> <p>Ok, let's not dig deeper because these topics are complex. I will leave links where you will find more information.</p> <p>To sum up. It is worth remembering that it is the main and the only identifier we need to locate our content.</p> <p>Read more about the CIDs here:</p> <ul>   <li><a href=\"https://proto.school/anatomy-of-a-cid\">proto.school/anatomy-of-a-cid</a></li>   <li><a href=\"https://docs.ipfs.io/concepts/content-addressing/#identifier-formats\">docs.ipfs.io/concepts/content-addressing/#identifier-formats</a></li> </ul> <p>Let's jump to the next crucial topic.</p> <p><strong>Pinning, why it is essential?</strong></p> <p>Pinning in the IPFS world is comparable to pinging some service to keep it 'alive'. It is very similar. The content on the IPFS network isn't stored forever if it isn't needed anymore. There are special 'garbage collector' services that will remove the contents which are not needed anymore. And what does it mean? It means that there have been no requests for such content since the last request, so that nodes won't store it anymore.</p> <p>An IPFS node can protect data from garbage collection using a so-called pinning service. Of course, you could run your node locally and pin the data, but usually, it is done by using a third-party service that runs many nodes and can provide pinning for you. I will focus on two of such services at the end of the article, so keep reading.</p> <p>When it comes to the NFTs, even when the collection author provided pinning for all assets by default (and they should), you can also pin the assets as a buyer by providing the CID. I will describe how to do this later in the article.</p> <p>   You can read more about pinning and persistence here: <a href=\"https://docs.ipfs.io/concepts/persistence/#persistence-versus-permanence\">docs.ipfs.io/concepts/persistence/#persistence-versus-permanence</a>   Let's see how to get our assets using the CID. </p> <p><strong>What is an IPFS gateway?</strong></p> <p>When you know the CID of your content on the IPFS, you can get it in many different ways. You can use the CLI tools, the desktop apps, or the most straightforward way - special web services called IPFS gateways.</p> <p>IPFS gateway is a standard web service that will locate your content and serve it in the browser. It doesn't matter which gateway you will use. For the same CID, all of them should return the same content. Let's take, for example, two of them as an example:</p> <ul>   <li><a href=\"https://ipfs.io/ipfs/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png\">https://ipfs.io/ipfs/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li>   <li><a href=\"https://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea.ipfs.dweb.link/7894.png\">https://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea.ipfs.dweb.link/7894.png</a></li> </ul> <p>As you can see, these are different web services, but when we use the same CID of the directory and the same file name, we will still get the same image.</p> <p>What is also worth mentioning is that you can use the IPFS URI schema in a Brave browser to get the same image. It is supported only in the Brave browser for now. It will look like this:</p> <ul>   <li><a>ipfs://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li> </ul> <p>You will find a list of gateways <a href=\"https://ipfs.github.io/public-gateway-checker/\">here</a>. Remember that also Elrond provides a custom IPFS gateway. See the same example below:</p> <ul>   <li><a href=\"https://media.elrond.com/nfts/asset/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png\">https://media.elrond.com/nfts/asset/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li> </ul> <p>The IPFS gateways are probably the simplest way to access, download or preview your content. Read more about the topic here: <a href=\"https://docs.ipfs.io/concepts/ipfs-gateway/#overview\">docs.ipfs.io/concepts/ipfs-gateway/#overview</a>.</p> <p><strong>Where can I learn more about IPFS?</strong></p> <p>Besides all links from previous chapters, I will leave a couple of links below. The IPFS is a broad and complex topic, but it is worth reading about it and learning more. Let's see where you will find more information:</p> <ul>   <li>Official docs: <a href=\"https://docs.ipfs.io/\">https://docs.ipfs.io/</a></li>   <li>Tutorials: <a href=\"https://proto.school/\">https://proto.school/</a></li>   <li>Youtube channel: <a href=\"https://www.youtube.com/c/IPFSbot\">https://www.youtube.com/c/IPFSbot</a></li>   <li>Awesome IPFS GitHub repo: <a href=\"https://github.com/ipfs/awesome-ipfs\">https://github.com/ipfs/awesome-ipfs</a></li> </ul> <h3>How is it used in the Elrond ecosystem?</h3> <p>Finally, let's jump into the Elrond ecosystem and see how we can use the IPFS when creating the NFTs on the Elrond chain.</p> <p>The main concept of the NFT token on the Elrond blockchain is that it is the ESDT token, so the standard Elrond token, but with additional metadata.</p> <p>There are no strict rules on what your NFT token should look like. I mean, what structure its attributes should have. The main field for keeping the data on-chain is the 'attributes' field. I won't focus much on how NFTs work on the Elrond blockchain because it is a topic for many different articles, and it was already covered partially. Also, see the <a href=\"https://docs.elrond.com/developers/nft-tokens/\">official docs on it</a>.</p> <p>When preparing the NFT, we need to split the data of our NFT token into the small batch, which will be kept on-chain, and all other stuff that will be kept off-chain using IPFS decentralized storage.</p> <p>On Elrond, for on-chain, we will keep only the information about the CIDs for the metadata JSON file with all additional data like traits, description, etc., and the actual asset CID and probably file names. Let's take a closer look and take the example from Elven Tools.</p> <p>Here is the example of the NFT minted using the Elven Tools: <a href=\"https://devnet-explorer.elrond.com/nfts/FTDD-5cdeea-03\">https://devnet-explorer.elrond.com/nfts/FTDD-5cdeea-03</a>.</p> <p>You will see that we have two assets linked using the IPFS gateway. The most popular gateway. The JSON file is the metadata for our token. You can preview its content, but this isn't important for now. The metadata file is added there, but this isn't a standard. The Elven Tools allows choosing if you want it there or not. It isn't required because the information about the metadata CID is located in the attributes. They are not displayed in the explorer directly. But when you preview the API response for this token, you will find that attributes are a base64 encoded string that after decoding will give you something like that: <code>metadata:bafybeifjntwejc7k7dedfaavravhnosc7xe4ceu5zmobjhhbob32uyu57m/93.json</code>. So the same CID and file name as in the assets in the explorer.</p> <p>Based on that, the Elrond API services will prepare additional data for your token. Like media and metadata objects. So it is essential to have such entry in your attributes field.</p> <p>For now, the only supported decentralized storage seems to be IPFS, but I think this is ok. IPFS is the most popular way of storing content in a decentralized manner. But Elrond's services for that will probably be extended in the future. For example, with the Arweave support.</p> <p>To sum up. Metadata, images, and all other assets should be kept off-chain using IPFS because it is much cheaper. The CID for the metadata and assets is critical in how Elrond API services work. The CID and file name for the metadata file should be provided in the 'attributes' field with the defined format and encoded with base64. This will open the door to proper operations on the NFT data and prepare appropriate API responses. It is also used for thumbnails generation and optimizations for assets serving. The metadata JSON file CID in the assets section is optional. Some of the marketplaces require that.</p> <h3>Helpful IPFS services and tools.</h3> <p>Last is the section about essential services commonly used for uploading and managing the assets on IPFS. There are a couple of them, but I want to focus on two here. These are:</p> <ul>   <li><a href=\"https://www.pinata.cloud/\">https://www.pinata.cloud/</a></li>   <li><a href=\"https://nft.storage/\">https://nft.storage/</a></li> </ul> <p>The Pinata is a top-rated service where you can upload a whole directory, and it will be pinned automatically for you. You will get your CID which you can use for your NFTs.</p> <p>The Pinata has free and paid plans. You can choose whatever suits your needs.</p> <p>I don't use Pinata much, but I like their pinning service for CIDs, which are not generated by their service. You could secure your assets even if you didn't upload them using Pinata. It is something that should always be done when you buy NFTs. Just in case.</p> <p>The nft.storage service is my preferred one. The main reason is that it is free, and they also use Filecoin to secure the contents. You can read more about it on their website. And still, all is free.</p> <p>Nft.storage allows uploading single files or CAR files, similar to standard TAR files. The functionality is identical to the Pinata. You will get your CID file, whether it will be a single file or directory/CAR.</p> <p>Both services allow uploading using their web interface or many different tools. The web interface won't be enough when you want to upload a massive set of data because of the browser's limitations. In such a case, you would need to use the CLI tool or any other provided. For example, nft.storage has an excellent <a href=\"https://nft.storage/docs/client/js/\">JavaScript client SDK for their API</a>.</p> <p>Another important thing is to keep in mind that even if you, as the collection creator, have uploaded the files and there is an option to remove them, this doesn't mean that when you remove the files, they will disappear from IPFS. As I mentioned, you can't remove or modify already uploaded content. It can only disappear when it is garbage-collected, which in the case of nft.storage will be hard because the content will also land on the Filecoin. But of course, as the creator, you should keep the files pinned there. Also, every buyer can pin their assets using, for example, Pinata and CIDs.</p> <h3>Summary</h3> <p>Hopefully, I was able to explain some basics and show you the path where you could start learning about decentralized storage and IPFS. The Elven Tools is prepared to consume the IPFS and keep the Elrond best practices so feel free to play around and test things.</p> <p>If you want to contact me, you will find all communication channels here: <a href=\"https://www.elven.tools/about.html\">www.elven.tools/about.html</a>.</p>","excerpt":"IPFS storage is a crucial part of every NFT ecosystem, not only the Elrond. It allows storing and accessing data in a decentralized and trustless way.","publicationDate":"2022-03-26","tags":["articles"],"coverImage":""}]