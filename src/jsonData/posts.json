[{"fileName":"cli-commands.html","title":"CLI Commands","body":"<h3>General commands</h3> <ul>   <li><code>elven-tools derive-pem</code> - derives the PEM file from seed phrase (keywords)</li>   <li><code>elven-tools collection-nft-owners</code> - get collection nft owners using the collection ticker (<a href=\"/docs/recipes#how-to-get-owners-addresses-using-the-collection-ticker\">see more</a>)</li>   <li><code>elven-tools deploy nft-minter</code> - deploys the smart contract (by default from the defined tag branch using the devnet, can be configured)</li>   <li><code>elven-tools init-dapp</code> - initialize the Nextjs Minter Dapp in custom directory</li> </ul> <h3>nft-minter commands</h3> <ul>   <li><code>elven-tools nft-minter issue-collection-token</code> [only owner] - issue main collection handle, it costs 0.05 EGLD, and it is a must in the Elrond chain. All NFTs will be under this collection. The cost here is a one-time payment for the whole collection.</li>   <li><code>elven-tools nft-minter set-roles</code> [only owner] - for now, the command sets the critical role for the collection handle. It is a 'create nft' role.</li>   <li><code>elven-tools nft-minter start-minting</code> [only owner] - by default, after deploying the smart contract, the minting is disabled. You would need to start it</li>   <li><code>elven-tools nft-minter pause-minting</code> [only owner] - you can also pause it at any moment</li>   <li><code>elven-tools nft-minter set-new-price</code> [only owner] - you can set a new price per NFT for the whole collection</li>   <li><code>elven-tools nft-minter giveaway</code> [only owner] - as an owner, you can give some random tokens to other addresses. (<a href=\"/docs/recipes#how-to-use-the-giveaway\">see more</a>)</li>   <li><code>elven-tools nft-minter set-drop</code> [only owner] - you can also split the minting into drops. These are 'waves' of minting where you can change prices and promote each one (v1 doesn't include any logic for revealing the CIDs with delay, the revealed NFTs will be sent in every drop). (<a href=\"/docs/recipes#how-to-use-drops\">see more</a>)</li>   <li><code>elven-tools nft-minter unset-drop</code> [only owner] - you can also disable the drop and pause minting</li>   <li><code>elven-tools nft-minter claim-dev-rewards</code> [only owner] - as an owner of the Smart Contract, you can always claim the developer rewards. Read more about them in the Elrond docs. (<a href=\"/docs/recipes#how-to-claim-dev-rewards\">see more</a>)</li>   <li><code>elven-tools nft-minter change-base-cids</code> [only owner] - you can change base IPFS CIDs only before any NFT was minted. Otherwise, it doesn't make sense to do that.</li>   <li><code>elven-tools nft-minter set-new-tokens-limit-per-address</code> [only owner] - it is possible to change the limits per address which are configured when deploying the Smart Contract</li>   <li><code>elven-tools nft-minter claim-sc-funds</code> [only owner] - this is treated as a fallback for royalties. The Smart Contract will receive the royalties as the creator, so there has to be a way to get them back. In the future the Smart Contract will probably also have dedicated claim functionality to be able to call the marketplace and get the royalties because some of the marketplaces don't send them automatically. (<a href=\"/docs/recipes#how-to-claim-royalties-and-other-funds\">see more</a>)</li>   <li><code>elven-tools nft-minter shuffle</code> - as a user, you can take part and ensure that the minting is random. This transaction will reshuffle the next index to mint. Everyone can run it.</li>   <li><code>elven-tools nft-minter mint</code> - the main mint function, you can mint NFTs using any <code>walletKey.pem</code> file</li>   <li><code>elven-tools nft-minter get-total-tokens-left</code> - the Smart Contract query, returns amount of tokens left</li>   <li><code>elven-tools nft-minter get-provenance-hash</code> - the Smart Contract query returns the provenance hash if provided when deploying</li>   <li><code>elven-tools nft-minter get-drop-tokens-left</code> - the Smart Contract query returns the number of tokens left per drop</li>   <li><code>elven-tools nft-minter get-nft-price</code> - the Smart Contract query, returns the current price</li>   <li><code>elven-tools nft-minter get-nft-token-id</code> - the Smart Contract query, returns the collection token id</li>   <li><code>elven-tools nft-minter get-nft-token-name</code> - the Smart Contract query, returns optional name for each NFT (if not configured NFTs will take the collection name)</li>   <li><code>elven-tools nft-minter get-collection-token-name</code> - the Smart Contract query, returns the collection token name</li>   <li><code>elven-tools nft-minter get-tokens-limit-per-address-total</code> - the Smart Contract query returns the tokens limit per address</li>   <li><code>elven-tools nft-minter get-minted-per-address-total</code> - the Smart Contract query returns the number of tokens minted per one address</li>   <li><code>elven-tools nft-minter get-minted-per-address-per-drop</code> - when the drop is configured, it will return the number of tokens minted per address per drop</li>   <li><code>elven-tools nft-minter get-tokens-limit-per-address-per-drop</code> - when the drop is configured, it will return the total limit of tokens per address per drop</li>   <li><code>elven-tools nft-minter populate-allowlist</code> - the command for preparing the allowlist, you will be able to read it from <code>allowlist.json</code> file or you can provide addresses by hand. There is a limit of 320 addresses per transaction (<a href=\"/docs/recipes#how-to-use-allowlist\">see more</a>)</li>   <li><code>elven-tools nft-minter enable-allowlist</code> - enable the allowlist, it won't be onsidered unles enabled even when it is filled with addresses,</li>   <li><code>elven-tools nft-minter disable-allowlist</code> - the option to disable the allowlist,</li>   <li><code>elven-tools nft-minter get-allowlist-size</code> - check the size of the allowlist,</li>   <li><code>elven-tools nft-minter is-allowlist-enabled</code> - check if allowlist is currently enabled,</li>   <li><code>elven-tools nft-minter get-allowlist-address-check</code> - check if provided address is included in the allowlist,</li>   <li><code>elven-tools nft-minter is-drop-active</code> - checks if there is an active drop at the moment</li>   <li><code>elven-tools nft-minter clear-allowlist</code> - It will clear the whole allowlist. The best is to keep a max of 1300 addresses in the allowlist at a time. Of course, if only you plan to clear it later. If you keep more and want to clear it, you can reach the gas limit for a transaction. So it would be best to split the allowlist per drop, keep it as small as possible and clear it each time.</li>   <li><code>elven-tools nft-minter remove-allowlist-address</code> - removes a single address from allowlist</li>   <li><code>elven-tools nft-minter is-minting-paused</code> - checks if the minting is paused,</li>   <li><code>elven-tools nft-minter get-total-supply</code> - returns the total supply for the collection,</li>   <li><code>elven-tools nft-minter get-total-supply-of-current-drop</code> - returns the supply of current drop</li> </ul>","excerpt":"Here you will find all CLI commands with short descriptions.","publicationDate":"2022-01-25","tags":["cli tool"],"coverImage":""},{"fileName":"cli-introduction.html","title":"CLI Introduction","body":"<p>The CLI tools is a standard Node CLI program which you can install using the npm package manager. It is best to install it globally by:</p> <pre><code class=\"language-bash\">npm install elven-tools -g </code></pre> <h3>What is it?</h3> <ul>   <li>The CLI tool helps to:     <ul>       <li>deploy the NFT minter Smart Contract on the Elrond blockchain</li>       <li>interact with the NFT minter Smart Contract on the Elrond blockchain</li>     </ul>   </li> </ul> <p>For now it is designed to deploy the contract: <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">elven-nft-minter-sc</a>.</p> <h3>How does it work?</h3> <p><strong>General how to:</strong></p> <ul>   <li><code>npm install elven-tools -g</code></li>   <li><code>elven-tools --version</code> or <code>elvent-tools -v</code></li>   <li><code>elven-tools --help</code> or <code>elven-tools -h</code> - for getting the commands on the root level</li>   <li><code>elven-tools nft-minter --help</code> or <code>elven-tools nft-minter -h</code> - for getting all the commands for the subcommand</li> </ul> <p><strong>Steps for deploying and interacting with the Smart Contract:</strong></p> <p>Check the detailed steps here: <a href=\"/docs/jump-start.html\">Jump start section</a>.</p> <p>Be aware that, by default, all will happen on the devnet. See <a href=\"/docs/recipes.html#how-to-use-the-configuration-file\">here</a> how to change it.</p> <p>Check all commands <a href=\"/docs/cli-commands.html\">here</a></p> <h3>Custom configuration options</h3> <p><strong>All of the configuration options are set by default, so you don't have to configure them if you will accept the defaults.</strong></p> <p>Below is an example of a <code>.elventoolsrc</code> config file with default values. You don't have to change the <code>config.ts</code> file. It is for library usage. <code>.elventoolsrc</code> is the only config file that should be used. It is not required if you will work on the devnet. In other cases, you would need to have it. It should be located in the same directory from which the <code>elven-tools</code> commands are triggeredâ€”the same directory as the one where the <code>walletKey.pem</code> file is located.</p> <pre><code class=\"language-json\">{   \"chain\": \"devnet\",   \"apiProviderEndpoint\": \"https://devnet-api.elrond.com\",   \"gatewayProviderEndpoint\": \"https://devnet-gateway.elrond.com\",   \"nftMinterSc\": {     \"version\": \"{tag version here or branch name, for example: v1.2.0}\",     \"deployNftMinterSC\": \"&#x3C;nft_minter_smart_contract_address_here> when you want to switch between chains or you want to use the cli as buyer\",     \"tokenSelingPrice\": \"&#x3C;price_of_the_nft_here> when you want to switch between chains or you want to use the cli as buyer\",     \"deployGasLimit\": 120000000,     \"issueCollectionTokenGasLimit\": 80000000,     \"issueValue\": \"0.05\",     \"assignRolesGasLimit\": 80000000,     \"issueTokenFnName\": \"issueToken\",     \"setLocalRolesFnName\": \"setLocalRoles\",     \"mintBaseGasLimit\": 12500000,     \"tokenSellingPrice\": \"\",     \"mintFnName\": \"mint\",     \"giveawayBaseGasLimit\": 12500000,     \"giveawayFnName\": \"giveaway\",     \"setDropFnName\": \"setDrop\",     \"setUnsetDropGasLimit\": 5000000,     \"unsetDropFnName\": \"unsetDrop\",     \"pauseUnpauseGasLimit\": 4500000,     \"pauseMintingFnName\": \"pauseMinting\",     \"unpauseMintingFnName\": \"startMinting\",     \"setNewPriceGasLimit\": 4500000,     \"setNewPriceFnName\": \"setNewPrice\",     \"shuffleFnName\": \"shuffle\",     \"shuffleGasLimit\": 5000000,     \"getTotalTokensLeftFnName\": \"getTotalTokensLeft\",     \"getProvenanceHashFnName\": \"getProvenanceHash\",     \"getDropTokensLeftFnName\": \"getDropTokensLeft\",     \"getNftPriceFnName\": \"getNftPrice\",     \"getNftTokenIdFnName\": \"getNftTokenId\",     \"getNftTokenNameFnName\": \"getNftTokenName\",     \"getCollectionTokenNameFnName\": \"getCollectionTokenName\",     \"getMintedPerAddressTotalFnName\": \"getMintedPerAddressTotal\",     \"getTokensLimitPerAddressTotalFnName\": \"getTokensLimitPerAddressTotal\",     \"getMintedPerAddressPerDropFnName\": \"getMintedPerAddressPerDrop\",     \"getTokensLimitPerAddressPerDropFnName\": \"getTokensLimitPerAddressPerDrop\",     \"changeBaseCidsFnName\": \"changeBaseCids\",     \"changeBaseCidsGasLimit\": 5000000,     \"setNewTokensLimitPerAddressFnName\": \"setNewTokensLimitPerAddress\",     \"setNewTokensLimitPerAddressGasLimit\": 5000000,     \"claimScFundsFnName\": \"claimScFunds\",     \"claimScFundsGasLimit\": 6000000,     \"allowlistBatchSize\": 320,     \"populateAllowlistFnName\": \"populateAllowlist\",     \"populateAllowlistBaseGasLimit\": 6000000,     \"getAllowlistFnName\": \"getAllowlistSize\",     \"isAllowlistEnabledFnName\": \"isAllowlistEnabled\",     \"getAllowlistAddressCheckFn\": \"getAllowlistAddressCheck\",     \"enableAllowlistFnName\": \"enableAllowlist\",     \"disableAllowlistFnName\": \"disableAllowlist\",     \"enableDisableAllowlistGasLimit\": 6000000,     \"isDropActiveFunctionName\": \"isDropActive\",     \"tokensPerOneTx\": 95,     \"clearAllowlistFnName\": \"clearAllowlist\",     \"clearAllowlistBaseGasLimit\": 5000000,     \"removeAllowlistAddressFnName\": \"removeAllowlistAddress\",     \"removeAllowlistAddressLimit\": 5000000,     \"isMintingPausedFnName\": \"isMintingPaused\",     \"getTotalSupplyFnName\": \"getTotalSupply\",     \"getTotalSupplyOfCurrentDropFnName\": \"getTotalSupplyOfCurrentDrop\"   },   \"minterDapp\": {     \"version\": \"{tag version here, for example: v1.0.3}\"   },   \"collectionNftOwners\": {     \"apiCallsPerSecond\": 5   } } </code></pre> <p><strong>Whole config with default values:</strong> <a href=\"https://github.com/ElvenTools/elven-tools-cli/blob/main/src/config.ts\">config.ts</a></p> <p>Remember, you don't have to change the <code>config.ts</code> file. It is for library usage. You don't have to clone the repository to change the configuration. <code>.elventoolsrc</code> is the only config file that should be used.</p> <h3>Limitations and caveats</h3> <ul>   <li>there are main limitations related to the Smart Contract. Remember that it is most likely that this CLI tool won't be used only in a way that everyone would want to, be aware that you can always change the names of the endpoints in the Smart Contract. Then you can also use the config file and change them here in the CLI</li>   <li>Smart Contract in version 1 doesn't have many mechanisms which will strongly limit unwanted behaviors. It only implements random minting, but in version 2, there will be more mechanisms for fair launches.</li> </ul> <h3>Issues and ideas</h3> <p>Please post issues and ideas <a href=\"https://github.com/ElvenTools/elven-tools-cli/issues\">here</a>.</p> <h3>Contact</h3> <ul>   <li><a href=\"https://t.me/juliancwirko\">Telegram</a></li>   <li><a href=\"https://twitter.com/JulianCwirko\">Twitter</a></li>   <li>julian.cwirko@gmail.com</li> </ul>","excerpt":"The CLI tools is a standard Node CLI program which you can install using the npm package manager.","publicationDate":"2022-01-26","tags":["cli tool"],"coverImage":""},{"fileName":"common-problems.html","title":"Common problems","body":"<p>Here you will find common problems when using the Elven Tools. In the future, there will be more improvements, good error messages, etc.</p> <h3>CLI deploy transaction error</h3> <p><code>Request error on url [transactions]: [{\"statusCode\":400,\"message\":\"\"}]</code></p> <p><strong>Problem</strong>: The problem occurs when deploying the smart contract with Elven Tools CLI with <code>elven-tools deploy nft-minter</code><br><strong>Cause</strong>: You either don't have funds on the wallet that you are using with Elven Tools, or you have mismatched the configuration with the actual PEM file<br><strong>Solution</strong>: Ensure that the PEM file corresponds to your chain type configuration (the devnet by default, even without the configuration file). The PEM file should be derived from the seed phrase corresponding to the chain you want to deploy the smart contract. Also, make sure that you have funded the wallet.</p> <h3>'Token not issued' - the error from smart contract results</h3> <p><strong>Problem</strong>: The problem occurs when setting the roles for the collection token with <code>elven-tools nft-minter set-roles</code><br><strong>Cause</strong>: There is a time required between issuing the token and assigning the roles. The transaction can fail if the setting roles command is fired too quickly.<br><strong>Solution</strong>: Wait a couple of seconds and call the command again.</p>","excerpt":"The Elven Tools includes the Smart Contract, CLI tool, and Minter Dapp for NFT launches. Every part of it can be used as a separate tool.","publicationDate":"2022-01-24","tags":["intro"],"coverImage":""},{"fileName":"dapp-api-proxy.html","title":"Dapp API proxy","body":"<p>Think of the Dapp API proxy as the Nextjs API rewrites on the backend side. Why is it even included? Because it helps to hide your actual API endpoint. A lot of the dapps use the public API endpoints. If you want to do that, this article won't be helpful for you. On the other hand, if you want to use a third-party service or your architecture, it might be worth reading more about it.</p> <h3>How the API rewrite works</h3> <p>Reminder, the Elven Tools Dapp code is <a href=\"https://github.com/ElvenTools/elven-tools-dapp\">here</a>.</p> <p>In the <code>.env.example</code> (and later in your proper <code>.env.local</code>) file, you will find a variable <code>ELROND_CUSTOM_API</code>. By default, there will be a public Elrond API endpoint, but this is a place for your custom API endpoint. The endpoint won't be exposed on the frontend. So you can use services such as Tatum or BlastAPI and put there your custom endpoint. This way, you will make it private but still usable by your dapp and only by it.</p> <p>Ok, so far, so good. Your endpoint won't be visible in public. What's next?</p> <p>In the <code>nextjs.config.json</code>, you will find the main rule for the rewrite. It is something like:</p> <pre><code class=\"language-javascript\">async rewrites() {   return [     {       source: '/api/:path*',       destination: `${process.env.ELROND_CUSTOM_API}/:path*`,     },   ]; }, </code></pre> <p>It is pretty simple. As you can see, we redirect all <code>/api/*</code> calls to the proper API endpoint. So the only API endpoint that will be visible on the frontend side is <code>/api/*</code> and all that is provided by your service provider. Sometimes it can be the same functionality as for api.elrond.com, and sometimes it will be limited to functionality from gateway.elrond.com.</p> <p>Ok, now you think my endpoint is proxied and hidden, but it is still public, and anyone can use it, right? Not really. See why.</p> <h3>Guard middleware</h3> <p>NextJS should block other hosts from accessing its API by default, but our <code>/api/*</code> endpoint is still accessible using Postman or any other App or CLI tool. So, as an additional check, the Elven Tools Dapp implements optional middleware that checks the <code>referer</code> header. It will check if the referer is the same as defined in the <code>API_ALLOWED_DAPP_HOST</code> env variable. Otherwise, it will throw the <code>403 Forbidden</code>. You can find the middleware in the <code>pages/api/_middleware.ts</code>.</p> <p>There is one caveat with that approach, if you want to test your API through proxy/rewrite using some third-party tool or even the browser, you won't be able to do that because of the middleware, but don't worry. It is all optional. To disable the guard, it is enough to remove the <code>API_ALLOWED_DAPP_HOST</code> from your <code>.env.local</code>. Still, remember that the proxied API will be the same as your primary API endpoint, so you can always test everything from outside the dapp using your original API endpoint.</p> <h3>What's next?</h3> <p>Check more topics <a href=\"/docs/minter-dapp-introduction.html#more-detailed-docs\">here</a>.</p>","excerpt":"The Elven Tools Dapp API proxy - how the API proxy and 'guard' middleware works.","publicationDate":"2022-04-19","tags":["minter dapp"],"coverImage":""},{"fileName":"dapp-backend-integration.html","title":"Dapp backend integration","body":"<p>Sometimes, with more extensive apps and more logic, like managing custom information about users, etc., there is a need to implement user verification on the app's backend side. The Minter Dapp doesn't require the backend verification to work. It uses a public blockchain, and the user signs every transaction, but still, it is good to know how to extend it.</p> <p>Elven Tools Dapp is an excellent base for building more complicated stuff on it. It uses the NextJS framework, so you also have a free backend setup. Here are basic steps on how you could verify the user on the backend side of your dapp:</p> <ol>   <li>Login user using one of the dapp auth providers (Web Wallet, browser extension, Maiar mobile app, and Ledger).</li>   <li>Pass the custom token when logging in using the <code>useLogin()</code> hook. You can do this by passing additional parameter: <code>useLogin({ token: 'someTokenHashHere' })</code>. It can be a randomly generated hash or some other solution for that.</li>   <li>You will get the signature back. It will also be saved in the local storage in the browser.</li>   <li>You already have an address, a custom token, and a signature at this stage. You can send it to your backend and verify it.</li>   <li>Then, you could prepare a JWT token and send it back to the frontend. From now on, the user can use the JWT token and authorize protected operations/endpoints.</li> </ol> <p>There are three important things here:</p> <ol>   <li>How will we get the public key?</li>   <li>What message will we verify?</li>   <li>How to verify it?</li> </ol> <p>The public key can be fetched using the user's address and erdjs methods. You can do this like that:</p> <pre><code>import { UserPublicKey } from '@elrondnetwork/erdjs-walletcore/out/userKeys'; import { UserVerifier } from \"@elrondnetwork/erdjs-walletcore\"; (...) const pubKey = new UserPublicKey(address.pubkey()); const verifier = new UserVerifier(pubKey); </code></pre> <p>The message is more complicated than just the custom token. We would need to prepare the message like that:</p> <pre><code>const msg = 'erdUserAddressHere' + 'yourCustomTokenHere' + JSON.stringify({}); </code></pre> <p>Then you would need to prepare the Signature instance:</p> <pre><code>import { Signature } from '@elrondnetwork/erdjs/out/signature'; (...) const signature = new Signature(Buffer.from(msg, 'hex')); </code></pre> <p>And finally, you can verify it:</p> <pre><code>import { SignableMessage } from \"@elrondnetwork/erdjs\"; (...) const signMessage = new SignableMessage({     address: address,     message: Buffer.from(message),     signature: signature, }); verifier.verify(signMessage); </code></pre> <p>You would also need to handle the expiration for the JWT token. The expiry for the dapp login is already handled by Elven Tools Dapp.</p> <h3>Full code example</h3> <pre><code class=\"language-typescript\">import { Address, SignableMessage } from \"@elrondnetwork/erdjs\"; import { Signature } from '@elrondnetwork/erdjs/out/signature'; import { UserPublicKey } from '@elrondnetwork/erdjs-walletcore/out/userKeys'; import { UserVerifier } from \"@elrondnetwork/erdjs-walletcore\";  function verifySignedMessage(message: string, sig: string, wallet: string) {   try {     const address = new Address(wallet);     const pubKey = new UserPublicKey(address.pubkey());     const verifier = new UserVerifier(pubKey);     const signature = new Signature(Buffer.from(sig, \"hex\"));      const signMessage = new SignableMessage({       address: address,       message: Buffer.from(message),       signature: signature,     });     return verifier.verify(signMessage);   } catch(e) {     console.log('error: ', e);     return false;   } }  // message format: address + loginToken (random phrase or smth.) + payload data, here empty const msg =   \"erd1....\" +   \"someHashTokenHere\" +   JSON.stringify({});  console.log(   verifySignedMessage(     msg,     \"signature_hash_here\",     \"erd1....\"   ) ); </code></pre> <p>Also please check the quick walkthrough video:</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/e2ope5WgOuM\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <p>You will find the full working example in the repository prepared by <a href=\"https://github.com/borispoehland\">@borispoehland</a>. Check it out: <a href=\"https://github.com/borispoehland/elven-tools-dapp-with-auth\">elven-tools-dapp-with-auth</a>. Be aware that the repository can be outdated.</p>","excerpt":"Elven Tools Dapp is an excellent base for building more complicated stuff on it. It uses the NextJS framework, so you also have a free backend setup.","publicationDate":"2022-04-19","tags":["minter dapp"],"coverImage":""},{"fileName":"dapp-deployment.html","title":"Dapp deployment","body":"<p>Let's look at the two most convenient and popular hosting providers out there. They are not only rich in features but also have an outstanding developer experience.</p> <h3>Netlify deployment</h3> <p>The <a href=\"https://www.netlify.com/\">Netlify</a> services are powerful because of two core things:</p> <ol>   <li>Cloud systems possibilities.</li>   <li>Excellent development experience.</li> </ol> <p>At first sight, It looks like Netlify is suitable only for static and simple websites, but it is so wrong to claim that. I will tell you why in the context of <a href=\"https://nextjs.org/\">NextJS</a> support on which our Elven Tools Dapp is built.</p> <p>Because NextJS is a full-stack framework, there is always a little more work to make the best custom setup. If you don't know what you are doing or want to have the best options right away, Netlify will be an excellent choice.</p> <p>They built a lot of tools and ready-to-use configurations. Let's see what Ntlify can do in the context of NextJS:</p> <ol>   <li>It discovers that you use NextJS and installs required plugins and configuration.</li>   <li>It supports <a href=\"https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration\">Incremental Static Regeneration</a> (ISR).</li>   <li>It supports NextJS <a href=\"https://nextjs.org/docs/api-routes/api-middlewares\">Middlewares</a>.</li>   <li>It supports Page routing and <a href=\"https://nextjs.org/docs/api-routes/introduction\">NextJS API</a> out of the box.</li>   <li>It supports <a href=\"https://nextjs.org/docs/basic-features/image-optimization\">image optimization</a> (<a href=\"https://nextjs.org/docs/api-reference/next/image#required-props\">next/image</a>).</li>   <li>It has docs pages, especially for NextJS. See it <a href=\"https://www.netlify.com/with/nextjs/\">here</a>.</li>   <li>It supports SSL by default.</li> </ol> <p>How is it possible?</p> <p>Netlify services uses special NextJS <a href=\"https://github.com/netlify/netlify-plugin-nextjs\">build pluging</a>. Don't worry. If you build on Netlify, you don't have to install it. It will be handled automatically.</p> <p>Ok, but what you should do to prepare the Elven Tools Dapp for the deployment. Let's go through the steps. Let's assume that you've cloned the repository and provided changes. Then, when you need to deploy, you can follow these steps: You will also be able to see the walkthrough video below.</p> <ol>   <li>Create a new project in the Netlify admin panel.</li>   <li>You will do this by connecting to the GitHub repository.</li>   <li>The only configuration you would need to provide is the environment variables (see it in the video).</li>   <li>By default, all code pushed to the 'main' branch will trigger the Netlify deployment.</li>   <li>Netlify creates the random domain name, but you can change it or/and you can connect your custom one.</li> </ol> <p>For more details on deploying a NextJS app, check the <a href=\"https://docs.netlify.com/\">official docs</a>. And for this specific case, please watch the walkthrough video below:</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/SQN-0XMxibU\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>Vercel deployment (TODO)</h3> <p>Soon there will also be some more information about how to deploy it using <a href=\"https://vercel.com/\">Vercel</a>. Stay tuned!</p>","excerpt":"Elven Tools Dapp walkthrough on deploying the app using Netlify and Vercel.","publicationDate":"2022-04-18","tags":["minter dapp"],"coverImage":""},{"fileName":"dapp-react-hooks-and-components.html","title":"Dapp React hooks and components","body":"<p>Below you will find the list of most essential utilities, hooks, and components with examples that are actual code from the Dapp. You can search them in the code to better understand how they work.</p> <p>There are much more hooks and tools, but most of them are already used in the ones listed below.</p> <p>The code samples are not ready to copy and paste. Please search them in the code.</p> <h4>useElrondNetworkSync()</h4> <p>The hook is responsible for synchronizing the network on each refresh. It should be used in the root component. Here is the <code>_app.tsx</code>.</p> <p>Why not the context wrapper? Because context wrappers with auth state data checks will break Next <a href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\">ASO</a>.</p> <p>This way, you can check the auth state in chosen places. You are not forced to do this constantly for the whole document tree.</p> <pre><code class=\"language-jsx\">import { useElrondNetworkSync } from \"../hooks/auth/useElrondNetworkSync\";  const ElvenToolsDapp = ({ Component, pageProps }: AppProps) => {   useElrondNetworkSync();   return (     &#x3C;ChakraProvider theme={theme}>       &#x3C;Component {...pageProps} />     &#x3C;/ChakraProvider>   ); }; </code></pre> <h4>useLogin()</h4> <p>The hook is responsible for providing a common interface for all login methods (web wallet, maiar app, browser extension and Ledger). Under the hood it uses three separate hooks: <code>useWebWalletLogin</code>, <code>useMobileAppLogin</code>, <code>useExtensionLogin</code>.</p> <pre><code class=\"language-jsx\">const { login, isLoggedIn, error, walletConnectUri, getHWAccounts } = useLogin(params); </code></pre> <p>The <code>login</code> function is a trigger function and it takes the <code>LoginMethodEnum</code> as type argument.</p> <p>The <code>params</code> for <code>useLogin</code> are: <code>token</code> and <code>callbackRoute</code>, both are optional. You will need to use a custom-generated token to get the auth signature back after connecting with one of 4 auth providers. The callback route can be used for some of the providers to be able to redirect the user after logging in.</p> <p>The <code>useLogin</code> hook looks like:</p> <pre><code class=\"language-jsx\">export const useLogin = (params?: Login) => {   const {     login: webLogin,     isLoggedIn: webIsLoggedIn,     isLoggingIn: webIsLoggingIn,     error: webLoginError,   } = useWebWalletLogin(params);    const {     login: mobileLogin,     isLoggedIn: mobileIsLoggedIn,     isLoggingIn: mobileIsLoggingIn,     walletConnectUri,     error: mobileLoginError,   } = useMobileAppLogin(params);    const {     login: extensionLogin,     isLoggedIn: extensionIsLoggedIn,     isLoggingIn: extensionIsLoggingIn,     error: extensionLoginError,   } = useExtensionLogin(params);    const {     login: ledgerLogin,     isLoggedIn: ledgerIsLoggedIn,     isLoggingIn: ledgerIsLoggingIn,     error: ledgerLoginError,     getHWAccounts,   } = useLedgerLogin(params);    const login = async (type: LoginMethodsEnum) => {     if (type === LoginMethodsEnum.extension) {       await extensionLogin();     }     if (type === LoginMethodsEnum.wallet) {       await webLogin();     }     if (type === LoginMethodsEnum.walletconnect) {       await mobileLogin();     }     if (type === LoginMethodsEnum.ledger) {       await ledgerLogin(ledgerAccountIndex);     }     return null;   };    return {     walletConnectUri,     getHWAccounts,     login,     isLoggedIn:       webIsLoggedIn ||       mobileIsLoggedIn ||       extensionIsLoggedIn ||       ledgerIsLoggedIn,     isLoggingIn:       webIsLoggingIn ||       mobileIsLoggingIn ||       extensionIsLoggingIn ||       ledgerIsLoggingIn,     error:       webLoginError ||       mobileLoginError ||       extensionLoginError ||       ledgerLoginError,   }; }; </code></pre> <h4>LoginModalButton</h4> <p>The component provides the <code>Connect</code> button with the modal, which will contain another four buttons for three different authentication possibilities (Maiar Mobile App, Maiar Defi Wallet - browser extension, Elrond Web Wallet, Ledger). You should be able to use it in any place on the website. It also includes the <code>LoginComponent</code> (login buttons).</p> <pre><code class=\"language-jsx\">import { LoginModalButton } from \"../tools/LoginModalButton\";  &#x3C;LoginModalButton />; </code></pre> <h4>Authenticated</h4> <p>The component is used as a small wrapper where we need to be in the authenticated context, for example, for all transactions.</p> <p>It can display the spinner and also the fallback React element.</p> <p><strong>Important</strong> Do not wrap it in big sections of the code. Its purpose is to be used multiple times on as small blocks as possible.</p> <p>But all code 'blocks' in your app that require the network and auth sync should be wrapped with it.</p> <pre><code class=\"language-jsx\">&#x3C;Authenticated   spinnerCentered   fallback={     &#x3C;>       &#x3C;Text fontWeight=\"bold\" fontSize=\"2xl\" textAlign=\"center\" mt={8}>         Connect your wallet!       &#x3C;/Text>       &#x3C;Flex mt={4} justifyContent=\"center\">         &#x3C;LoginModalButton />       &#x3C;/Flex>     &#x3C;/>   } >   &#x3C;Box>Do something here in the auth context...&#x3C;/Box> &#x3C;/Authenticated> </code></pre> <h4>useScTransaction()</h4> <p>The hook provides all that is required for triggering smart contract transactions. useScTransaction can also take a callback function as an argument.</p> <pre><code class=\"language-jsx\">const { pending, triggerTx, transaction, error } = useScTransaction({ cb });  const mint = async (tokensAmount: number) => {   const tokens = tokensAmount || 1;   const totalPayment = new BigNumber(tokenSellingPrice).times(tokens);   triggerTx({     func: new ContractFunction(mintFunctionName),     gasLimit:       mintTxBaseGasLimit + (mintTxBaseGasLimit / 1.4) * (tokensAmount - 1),     args: [new U32Value(tokens)],     value: TokenPayment.egldFromBigInteger(totalPayment),   }); }; </code></pre> <h4>useScQuery()</h4> <p>The hook uses useSWR under the hood and can be triggered on a component mount or remotely on some action. It has two different states for the pending action. For initial load and on revalidate. It also takes one of two return data types: 'int' and 'string'. You can still use the string type for boolean and check if you will get <code>01</code>, which is <code>true</code>. For now, it assumes that you know what data type will be returned by a smart contract.</p> <pre><code class=\"language-jsx\">const {   data: queryResult,   fetch, // you can always trigger the query manually if 'autoInit' is set to false   isLoading, // pending state for initial load   isValidating, // pending state for each revalidation of the data, for example using the mutate   error, } = useScQuery({   type: SCQueryType.INT, // can be int or string   payload: {     scAddress: mintSmartContractAddress,     funcName: queryFunctionName,     args: [],   },   autoInit: false, // you can enable or disable the trigger of the query on the component mount }); </code></pre> <h4>useLoggingIn()</h4> <p>The hook will provide information about the authentication flow state. It will tell if the user is already logged in or is logging in.</p> <pre><code class=\"language-jsx\">const { isLoggingIn, error, isLoggedIn } = useLoggingIn(); </code></pre> <h4>useAccount()</h4> <p>The hook will provide information about the user's account data state. The data: address, nonce, balance.</p> <pre><code class=\"language-jsx\">const { address, nonce, balance } = useAccount(); </code></pre> <h4>useLoginInfo()</h4> <p>The hook will provide the information about the user's auth data state. The data: loginMethod, expires, loginToken, signature. Login token and signature won't always be there. It depends if you'll use the token. Check <a href=\"/docs/dapp-backend-integration.html\">Elven Tools Dapp backend integration article</a> for more info.</p> <pre><code class=\"language-jsx\">const { loginMethod, expires, loginToken, signature } = useLoginInfo(); </code></pre>","excerpt":"The Elven Tools Dapp React hooks and components that can be used in different combinations.","publicationDate":"2022-04-17","tags":["minter dapp"],"coverImage":""},{"fileName":"dapp-structure.html","title":"Dapp structure","body":"<p>Here you will find a description of all crucial parts of the Dapp and how all is structured. Besides that, you'll find more detailed descriptions of each piece in other sections.</p> <p>Remember that the Dapp is built with the NextJS framework. It is good to know at least the basics of it. But don't worry, you should also be good after reading these docs assuming that you know how to work with React.</p> <h3>Main sections of the codebase:</h3> <ol>   <li>Global state</li>   <li>Dapp required configuration</li>   <li>React custom hooks</li>   <li>NextJS pages + api configuration</li>   <li>React custom UI components</li> </ol> <h3>Global state</h3> <p>The Dapp does not include the <a href=\"https://github.com/ElrondNetwork/dapp-core\">dapp-core</a> library, it handles all using only <a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs\">erdjs SDK</a>, so it requires its global state management.</p> <p>The Elven Tools Dapp uses <a href=\"https://github.com/pmndrs/valtio\">valtio</a> - a simple but compelling state management library for React. You'll read more about it in their docs. The most important is to know where it is used in the code and why.</p> <p>The global state configuration sits in the <a href=\"https://github.com/ElvenTools/elven-tools-dapp/tree/main/store\">store</a> directory in the repository. You will find there the auth and network global stores. The 'network' is just a static object which keeps the information of the dapp provider and network provider. It will re-init them on every hard refresh. And for auth, we use global state with valtio.</p> <p>The state is also synchronized with the localStorage to be able to reinitialize all required states on hard refresh. You will find such entries in the localStorage:</p> <pre><code>elven_tools_dapp__account: {\"address\":\"\",\"nonce\":0,\"balance\":\"\"} </code></pre> <pre><code>elven_tools_dapp__loginInfo: {\"loginMethod\":\"\",\"expires\":0,\"loginToken\":\"\",\"signature\":\"\"} </code></pre> <p>The state is reused in many places in the app. There are custom Ract hooks for this purpose. We will check them later in the article.</p> <h3>Dapp required configuration</h3> <p>The Dapp requires an initial configuration. It will be described in more detail in a dedicated section of the docs, so here is only a quick mention of what is where.</p> <p>The most important would be to set up .env variables. You'll find the example here: <a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/.env.example\">.env.example</a>. For deployment, you will also need to set them up. It can differ for different hosting providers or workflows. We will check the most simple ones, Netlify and Vercel, in separate docs sections.</p> <p>The other place for configuration is the <a href=\"https://github.com/ElvenTools/elven-tools-dapp/tree/main/config\">config</a>. There are four different config files. The one for UI configuration, mostly Chakra UI variables. The one for the smart contract configuration. This is the copy of the data configured on the contract, but it helps keep the low number of API calls. Otherwise, every Dapp usage would generate a couple of queries for static data. Even with the cache, it can still be problematic. There is also a config for the network and static data for the Minter use case. Like the team, faq, etc.</p> <h3>React custom hooks</h3> <p>The whole logic is based on custom React hooks. There are many of them, but generally, the logic isn't very complicated. You'll find them here: <a href=\"https://github.com/ElvenTools/elven-tools-dapp/tree/main/hooks\">hook</a>.</p> <p>The most difficult to understand and, at the same time, the most important would be probably <code>useElrondNetworkSync</code>. It is responsible for syncing the whole network, auth providers, and user accounts. It is essential to call it as soon as possible. If needed, you can also optimize component rerenders. The Elven Tools Dapp already has some of the optimization implemented.</p> <p>There are also hooks responsible for auth providers initialization, like Maiar mobile app, browser extension, Ledger, and web wallet. Some hooks will serve the info about the user, auth status, etc.</p> <p><a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/hooks/auth/useLogin.tsx\">useLogin</a> hook includes all auth providers. This is just an abstraction. You could also want to use one of the providers, not all. You'll still be able to do that.</p> <p>See more here <a href=\"/docs/dapp-react-hooks-and-components.html\">Dapp React hooks and components</a></p> <h3>NextJS pages + api configuration</h3> <p>With the Elven Tools Dapp, you are not limited to what you will see at the beginning. You can add more pages and change whatever you want. All is based on <a href=\"https://nextjs.org/\">NextJS</a> framework, a complete full-stack solution.</p> <p>In the <a href=\"https://github.com/ElvenTools/elven-tools-dapp/tree/main/pages\">pages</a> directory, you will find actual pages. The NextJS framework builds the routing based on this directory. You can read more about it here: <a href=\"https://nextjs.org/docs/basic-features/pages\">Pages</a>.</p> <p>As you will see, there is also the api directory inside the <code>pages</code>. Here you will find a configuration for the API endpoint. In this case, we have there the middleware logic, which will block the usage of the API by third-party services. Only the same host will be able to use it, so our instance of the Dapp. You can always disable that, but it is beneficial when you care about the API traffic. Most useful for paid API providers. Read more about it here: <a href=\"/docs/dapp-api-proxy.html\">Dapp API Proxy</a>.</p> <h3>React custom UI components</h3> <p>Finally, there are, of course, custom UI components. You will find them in the <a href=\"https://github.com/ElvenTools/elven-tools-dapp/tree/main/components\">components</a> directory. There is quite a lot of them. Most important are:</p> <ul>   <li><a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/components/LoginComponent.tsx\">LoginComponent</a> - this one will handle all auth processes. It will render all auth providers buttons and connect them using the useLogin hook</li>   <li><a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/components/LoginModalButton.tsx\">LoginModalButton</a> - the button that also includes the modal wrapper for the LoginComponent</li>   <li><a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/components/MintForm.tsx\">MintForm</a> - this one will render the for minting with the input for the number of tokens to mint and all required states</li> </ul> <p>Other essential parts are mainly specific to the current use case, so the minting dapp. But remember that you can use this Dapp is the boilerplate for any project you want to build.</p> <p>See more here <a href=\"/docs/dapp-react-hooks-and-components.html\">Dapp React hooks and components</a></p> <h3>What's next?</h3> <p>Check more topics <a href=\"/docs/minter-dapp-introduction.html#more-detailed-docs\">here</a>.</p>","excerpt":"The Elven Tools Dapp files structure and logic behind all crucial parts.","publicationDate":"2022-04-21","tags":["minter dapp"],"coverImage":""},{"fileName":"elven-tools-workflows.html","title":"Elven Tools workflows","body":"<p>Many possible endpoints on the <a href=\"/docs/sc-introduction.html\">Smart Contract</a>. There is also a lot of documentation <a href=\"/docs/jump-start.html\">here</a> and <a href=\"/docs/cli-introduction.html\">there</a>. But how exactly should one work with the Elven Tools? Let's see the options and how you could sell and distribute your NFTs.</p> <h3>What we will tackle here</h3> <ol>   <li>What you can do and what you can't do with the first version of Elven Tools.</li>   <li>Examples of the scenarios and how to configure them.</li> </ol> <p>All scenarios can be modified and improved. These are probably the most often used scenarios on how to run the collection using Elven Tools.</p> <h3>What is possible and what's not</h3> <p>The first version of the Smart Contract works on the trendy principle of a 'candy machine'. You can read more about it here: <a href=\"/docs/tips-on-buying-nfts-on-the-elrond-blockchain.html\">Tips on buying NFTs on the Elrond blockchain</a>.</p> <p>In general, you pay, and you get randomly selected NFT. In the article linked above, you will find some more thoughts about the pros and cons of such a solution, but here let's focus on exactly what you can do and what you can't.</p> <p><strong>You can:</strong></p> <ul>   <li>you can receive the EGLD, randomly mint the NFT and send it to the buyer</li>   <li>you can split the whole collection into minting 'waves', called 'drops' here</li>   <li>you can give away tokens to chosen addresses (this is also randomly minted)</li>   <li>you can prepare an 'allowlist' and allow only eligible addresses to mint, then you can enable or disable it at any given time</li>   <li>you can start and pause the minting at any given time</li>   <li>you can change prices at any given time (of course should be appropriately planned and communicated)</li>   <li>you can change the tokens limit per one address at any given time in total</li>   <li>you can claim royalties sent to the Smart Contract from a marketplace</li>   <li>you can claim the developer rewards (as an owner of the Smart Contract, you will get the rewards too, it is 30% of the fee of each Smart Contract call)</li> </ul> <p><strong>You can't:</strong></p> <ul>   <li>you can't postpone sending the NFT token to the buyer's wallet</li>   <li>you can't send the NFT token with hidden assets</li>   <li>you can't take other currency than EGLD (at least for now, there are plans to implement that)</li>   <li>you can't disable the random minting functionality - it is essential for fair distribution</li> </ul> <p>There is another version of the contract planned, or it is better to say, a new Smart Contract that will implement another approach to fair distribution. You can read about it in the article linked above. Ok, enough theory, let's see the practical scenarios to use.</p> <h3>Examples of scenarios</h3> <p>Please keep in mind that these are only my ideas, you don't have to do this that way, and you can mix all possible endpoint calls to achieve your perfect flow. These are just examples to explain why all the endpoints are there. I will also describe how to prepare all of that using the Elven Tools CLI because it is simpler and faster. But you could also prepare the Smart Contract without it, for example, using <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy\">erdpy</a>.</p> <p><strong>Let's list all of my ideas on how we can do this first:</strong></p> <ol>   <li>Simple minting - all at once.</li>   <li>Simple minting with allowlist - all at once with allowlist.</li>   <li>Minting is divided into drops with different prices.</li>   <li>Minting with a giveaway.</li>   <li>A little bit of everything.</li> </ol> <p>Remember that all of the described below transactions are owner only, which means that the only owner of the Smart Contract can run it. So the wallet which deploys the Smart Contract.</p> <p><strong>Simple minting - all at once</strong></p> <p>Elven Tools allows mint without configuring other stuff like allowlist, drops, etc. You need to go through the required steps after deployment and start the minting process. You'll find all info about how to deploy and configure initial stuff here: <a href=\"/docs/jump-start.html\">Elven Tools Jumpstart</a>.</p> <p>When you deployed and ran all required transactions, you will be able to start minting. Let's see how.</p> <p>To start minting, you have to run the command:</p> <pre><code>elven-tools nft-minter start-minting </code></pre> <p>Of course, we assume that the Smart Contract is correctly deployed, the collection token is issued and it has proper roles. Again, you will find all about it here: <a href=\"/docs/jump-start.html\">Elven Tools Jumpstart</a>. Please let me know if something there is still not clear. I will improve the docs.</p> <p>That's it. Now your community can freely buy and mint the tokens till the end of the collection. You don't have to do anything more. Of course, you can still pause the minting:</p> <pre><code>elven-tools nft-minter pause-minting </code></pre> <p>And you can do whatever you need. You can even change the price. This isn't like you need to decide on one scenario. Remember about that. But for simplicity, I want to focus on examples.</p> <p>Pros of such an approach:</p> <ul>   <li>simplicity - you don't have to care about additional promotion and setup</li>   <li>if a project is quite popular, the collection will be probably sold out in a couple of minutes or hours</li> </ul> <p>Cons of such approach:</p> <ul>   <li>you won't have many tools to build the community and hype around it,</li>   <li>it can be heavy for your dapp, so it should be well prepared in such a case. Don't rely on public API or build the website with cache solutions. But generally, don't rely on public API if you can ;)</li> </ul> <p>It is a straightforward scenario and probably not very often used. Let's see what more we can do.</p> <p><strong>Simple minting - all at once with allowlist</strong></p> <p>This scenario is the same as the one above. What is added here is the 'allowlist'. A list of prepopulated addresses on the Smart Contract will be the only ones that can mint if the 'allowlist' is enabled. Let's see what we need to make it happen.</p> <p>First, you would need to populate the 'allowlist' with addresses. You can do this using the JSON file with a max of 320 addresses per one transaction or providing them by hand using a CLI prompt.</p> <p>If you can, please prepare the <code>allowlist.json</code> file and put it in the root dir, where you keep your walletKey.pem file and from where you run the <code>elven-tools</code> commands.</p> <p>You need to run the command:</p> <pre><code>elven-tools nft-minter populate-allowlist </code></pre> <p>The CLI will detect it and ask you if you want to continue.</p> <p>If you have more than 320 addresses, please repeat the operation. Remember to replace old addresses with new ones in the allowlist.json file. If you send the same addresses again, nothing will happen, there is no way to have duplicates on the smart contract, but you will lose some EGLD on the transaction fees.</p> <p>To provide addresses by hand, you would need to run the same command but remove or change the name of the <code>allowlist.json</code> file. Then the CLI will ask you to provide the addresses by hand. You can use commas to separate them.</p> <p>When the list is populated, you need to enable the 'allowlist'. You can do this by running:</p> <pre><code>elven-tools nft-minter enable-allowlist </code></pre> <p>From now on, only eligible addresses can mint. You would probably handle it in your dapp, but generally, if someone tries to mint and their address isn't on the list, the transaction will fail.</p> <p>You can disable the allowlist at any given time by:</p> <pre><code>elven-tools nft-minter disable-allowlist </code></pre> <p>Then standard minting starts, and every address can mint.</p> <p>It is important that the 'allowlist' does not keep the information about how many tokens a particular address can mint. The Smart Contract will respect global settings, total limits per the whole collection, and limits per drop. These limits can be changed at any given time. Please refer to the <a href=\"/docs/cli-commands.html\">docs</a> on how to do that.</p> <p>Ok, now we know how to use the 'allowlist' to promote and organize the presale for only eligible addresses.</p> <p>Pros of such an approach:</p> <ul>   <li>all the pros from the previous scenario</li>   <li>allowlist lets you organize the presale. You can also change prices after allowlist is disabled</li> </ul> <p>Const of such approach:</p> <ul>   <li>all the cons from the previous scenario</li>   <li>you need to handle this in your dapp not to confuse users. There are queries available on the Smart Contract, which will allow checking if the 'allowlist' is enabled and also to check if an address is on the list</li> </ul> <p><strong>Minting divided into drops with different prices</strong></p> <p>As I wrote before, you can mix all of the scenarios. You can also use the 'allowlist' here. Here let's focus only on the 'drops' functionality.</p> <p>The 'drops' functionality is optional. You don't have to use these to mint/sell. It is useful to divide your process into 'waves' spread in time. You have 9999 tokens in a collection, and you would like to have three drops/waves of minting each of 3333 NFTs. You can prepare the whole marketing for that and also the price strategy.</p> <p>What is essential here, and for many, it is a con of such a Smart Contract, is that when you distribute the first drop, it will for sure land on the second market. But it isn't always bad. You could check how prices form around that and adjust your fees for the next drop. Of course, it is better not to reveal prices for the following drops in such a case.</p> <p>Ok, so how to configure these?</p> <p>First, you would need to set the first drop:</p> <pre><code>elven-tools nft-minter set-drop </code></pre> <p>You will be asked how big is the drop, so with our example, it will be 3333 tokens, and what is the limit per one address per one drop. The limit per drop can be different than the total limit per collection, but it should always be smaller than the total limit. That's all that you need to do. Then you would need to start minting. After all 3333 tokens are sold, the Smart Contract will pause the minting process automatically. Of course, you would need to handle this on the dapp. Some queries will return how many tokens are already minted by drop and minted per one particular address. Please check all <a href=\"/docs/cli-commands.html\">here</a>.</p> <p>If needed, you can also unset/disable the actual drop.</p> <pre><code>elven-tools nft-minter unset-drop </code></pre> <p>You can also set another one at any time, which will overwrite the previous one. You won't select the amount bigger than tokens left to mint.</p> <p>What is important here is the possibility to set different prices for every drop. When the drop is sold out, you can change the price without starting the minting:</p> <pre><code>elven-tools nft-minter set-new-price </code></pre> <p>Then when the time comes, you can just set a new drop and start minting. Or you can even begin minting without setting the next drop.</p> <p>Pros of such a solution:</p> <ul>   <li>all from the previous scenarios</li>   <li>you will have a lot more control over the marketing and planning in time</li> </ul> <p>Const of such solution:</p> <ul>   <li>all from the previous scenarios</li>   <li>it is simpler for a mistake. You could start at the wrong moment or begin with the old price. Of course, you can pause it at any given time, but some tokens could be minted already</li>   <li>a lot of more planning is required and tests on the devnet</li> </ul> <p><strong>Minting with giveaways</strong></p> <p>The following interesting functionality is a <code>giveaway</code>. This is something which is used very often. It allows the operator to give randomly selected NFTs to any addresses they want. It could even be their address. Usually, it is used for marketing and rewarding in many different contests and lotteries in a project's community.</p> <p>You can use the giveaway endpoint at any given time. There will be no payment in this case. In most cases, it will probably be used initially, even before the process starts. But you can also use it in the middle of the process, but it is advisable to be careful when a drop is defined and active. It could affect the drop's final available amount of tokens if the drop is the last one, and there won't be any tokens left after using the giveaway. So use it at the beginning, the best even before the process starts or in between drops when the process is paused.</p> <p>Ok, let's see how to use it:</p> <pre><code>elven-tools nft-minter giveaway </code></pre> <p>You will be asked to provide the addresses in the CLI prompt. You can give/mint the tokens in this special case even when the whole minting process is paused.</p> <p>Remember that they will still be minted randomly. In the spirit of fair distribution, there is no way to choose a particular one to send.</p> <p>Pros of such a scenario:</p> <ul>   <li>all from the previous scenarios</li>   <li>you will be able to thank anyone you need to thank and send them the NFTs for free</li> </ul> <p>Cons of such scenario:</p> <ul>   <li>some general cons from the previous scenarios</li>   <li>basically, no additional cons if you are using it properly</li> </ul> <h3>A little bit of everything type scenario</h3> <p>In the last section of this article, I would like to focus on a custom scenario with which I would probably go.</p> <p>For example, purposes let's say I have a collection of 3333 NFTs.</p> <p>Let's start with a 'giveaway' process. I would probably prepare a list of addresses of people I want to thank. It could be a designer, or developer, or my friend. I would probably do this before even starting the whole process. Let's say I want to give 33 tokens at the beginning. I would use the <code>elven-tools nft-minter giveaway</code> command. So, now I have 3300 tokens left. I can check that using the query <code>elven-tools nft-minter get-total-tokens-left</code> can be run by everyone, not only by the owner of the Smart Contract.</p> <p>The following step would be to prepare the 'allowlist'. I could get addresses from closed discord groups or Twitter, competitions, and lotteries. Preparation of such a list would probably take some time, so I could also prepare some marketing and social media communication. I can populate the Smart Contract storage with addresses when the list is ready. I would use the <code>elven-tools nft-minter populate-allowlist</code>.</p> <p>I will prepare the drop to be adequate to the 'allowlist' addresses when the list is in place. So, for example, if I would like to have three tokens per address per drop, and my 'allowlist' has 100 addresses, I would set the drop to 300 tokens max.</p> <div class=\"docs-info-box\"><strong>Important!</strong>Because of the gas limits, it is advised to keep the allowlist as small as possible if you plan to clear it with `elven-tools nft-minter clear-allowlist`. It should be ok to max 1300 addresses at a time. With more, when you would like to clear it, you can reach the transaction gas limit, and the transaction will fail. The best is to keep the allowlists small and use drops to make more of them.</div> <div class=\"docs-info-box\"><strong>Important</strong> Also, please remember that each drop can have its limits per address, but a single address won't be able to mint more than the overall limit per token per the whole collection even if there is still room for that in current drop. Always be careful and plan it that way that everything sums up. You can change the global limit per address by: `elven-tools nft-minter set-new-tokens-limit-per-address`.</div> <p>Let's go back to our custom scenario. So when you have the drop set to 300 tokens, we can set up the price. It will probably be something low as for the start and allowlist. You can do this by: <code>elven-tools nft-minter set-new-price</code>.</p> <p>Then we can start the minting for only eligible addresses from the allowlist. All other attempts will fail. You can always check how many tokens are left by: <code>elven-tools nft-minter get-drop-tokens-left</code>. The Smart Contract will pause the minting process when all 300 tokens are minted.</p> <p>When all tokens from the first drop are minted, I will prepare all the marketing for the next drop. I would probably not reveal the price yet. I would like to know what is happening with the first 333 tokens on the secondary market. What is the price, etc.? I would probably plan the next giveaway. Let's say I would give 100 tokens. Then I would prepare the next drop. Now I have 2900, so I would probably go with 2000 and 900 drop. You need to repeat the steps. Remember always to look out in which state the Smart Contract is. Remember about changing prices, and adequately stop and start minting.</p> <div class=\"docs-info-box\">Please keep in mind that this is a quick idea for example purposes. Do it as you think it will be best for your project. It is all quite elastic.</div> <h3>Summary</h3> <p>Here are a couple of ideas on preparing the Smart Contract to sell the NFT collection on the Elrond blockchain.</p> <p>Hopefully, it will be helpful, and the examples will help better understand the idea behind all the existing endpoints on the Smart Contract.</p> <p>There will probably be more improvements. Please let me know if you will find a bug or have some ideas to improve the toolset. You can write to me directly: <a href=\"https://twitter.com/JulianCwirko\">Twitter</a> and <a href=\"https://t.me/JulianCwirko\">Telegram</a>. Or you can report an issue on GitHub for the Smart Contract <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/issues\">here</a> and the CLI <a href=\"https://github.com/ElvenTools/elven-tools-cli/issues\">here</a>.</p>","excerpt":"How exactly should one work with the Elven Tools? Let's see the options on how you could randomly mint and distribute your NFTs","publicationDate":"2022-01-25","tags":["articles"],"coverImage":""},{"fileName":"how-to-start-with-the-dapp.html","title":"How to start with the Dapp","body":"<p>In this section, I'll explain how to start with the Elven Tools Dapp. You will find the repository here: <a href=\"https://github.com/ElvenTools/elven-tools-dapp\">ElvenTools/elven-tools-dapp</a>.</p> <p>There are a couple of steps to run it locally and start working on modifications:</p> <ol>   <li>Clone/Download the repository code</li>   <li>Install npm dependencies</li>   <li>Configure basic .env variables</li>   <li>Configure smart contract information (optionally other things too).</li>   <li>Run the dapp locally</li>   <li>Prepare it for deployment</li> </ol> <p>The only essential thing here will be the sufficiently configured Node environment. I recommend using the LTS versions of Node and being careful with permissions on your system. The best is to use the Node version manager. I recommend <a href=\"https://github.com/nvm-sh/nvm\">NVM</a>. Also, the best would be to work on Linux/macOS or Windows with a Linux subsystem.</p> <h3>Clone/Download/Initialize the repository code</h3> <p>There are three ways of getting the Dapp's code:</p> <ol>   <li>By using Elven Tools CLI (since v1.8.1).</li>   <li>By using the git command and cloning the repository.</li>   <li>By downloading it as a zip file from the repository.</li> </ol> <p>You can use the <code>elven-tools init-dapp</code> command. It will:</p> <ul>   <li>download the code</li>   <li>install npm dependencies</li>   <li>copy the .env.example into .env.local (required step in all cases)</li> </ul> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Erjabk7d0HU\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <p>The other way is to clone the repository using the git command:</p> <pre><code>git clone https://github.com/ElvenTools/elven-tools-dapp.git </code></pre> <p>And finally, you can also download it as a zip file using this URL:</p> <pre><code>https://github.com/ElvenTools/elven-tools-dapp/archive/refs/heads/main.zip </code></pre> <p>You can also download a specific version of it. Check the release and download the source code. For example: <a href=\"https://github.com/ElvenTools/elven-tools-dapp/releases/tag/v1.0.1\">v1.0.1</a>.</p> <h3>Install npm dependencies</h3> <p><strong>This step is handled automatically by <code>elven-tools init-dapp</code>. Otherwise, you would need to do that manually.</strong></p> <p>When you have the code, you need to install all npm dependencies. Just run:</p> <pre><code>npm install </code></pre> <h3>Configure basic .env variables</h3> <p>The <code>elven-tools init-dapp</code> command will copy .env.example into .env.local. So you would only need to change the variables. Otherwise, you would need to do that manually.</p> <p>The Elven Tools Dapp uses a .env file for crucial environment variables. These are:</p> <ul>   <li>the chain type (devnet, testnet, mainnet),</li>   <li>the API endpoint</li>   <li>the public API proxy endpoint</li>   <li>the Dapp hostname</li> </ul> <p>You will find the example of such .env file here: <a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/.env.example\">.env.example</a>. It contains the config which will allow running the dapp locally, so you can copy it or change its name to <code>.env.local</code>. Not all variables there are public, some of them should be kept secret, so this is why there is included only an example in the repo. You should always keep them in <code>.env.local</code> when working. For production, you would need to configure them within your CI pipeline or on the hosting provider side, for example, in Netlify.</p> <p>Variables with the <code>NEXT_PUBLIC_</code> prefix can be read by every user interacting with the dapp. All other variables will be private and not accessible on the frontend, so it is good. For example, here, we can hide the actual API endpoint.</p> <p>Read more about env vars in NextJS here: <a href=\"https://nextjs.org/docs/basic-features/environment-variables\">Environment Variables</a>.</p> <h3>Configure smart contract information</h3> <p>The Elven Tools Dapp is prepared to work with properly configured and deployed Elven Tools Smart Contract. There is an additional configuration for the smart contract to save some API calls and traffic, which is essential in the case of paid third-party API providers. You will find it in the <code>config</code> directory <a href=\"https://github.com/ElvenTools/elven-tools-dapp/blob/main/config/nftSmartContract.ts\">here</a>. Each variable is described so that I won't repeat it here.</p> <p>Remember that this config should always sync with the smart contract. Otherwise, the Dapp will show incorrect data or stop working. In the future, it will be served as an option. By default, the data will be queried on the smart contract.</p> <p>In the same directory, there are also other configuration files. All should also be descriptive there. These are mainly UI-based configurations, like the Chakra UI theme configuration or static data for the Dapp. You can review them and change whatever you need.</p> <h3>Run the dapp locally</h3> <p>To run the Dapp locally, you would need to run:</p> <pre><code>npm run dev </code></pre> <p>This will run the Dapp locally under the <code>http://localhost:3000</code>.</p> <p>You can also build it locally and check the production-ready version:</p> <pre><code>npm run build </code></pre> <p>then:</p> <pre><code>npm start </code></pre> <h3>Prepare it for deployment</h3> <p>There will be a more detailed tutorial on deploying the dapp using Vercel and Netlify. But here, what is most important is to be aware that you need to have the proper configuration. Proper chain type, appropriate API endpoints, and proper smart contract configuration. Only then you can properly deploy the dapp.</p> <p>For example, Netlify allows configuring env vars using the administration panel. Then you will need to configure the branch in the repository from which Netlify will deploy the dapp.</p> <p>Because it is a NextJS-based app, Netlify will recognize it, and it will use additional plugins to make the deployment as smooth as possible. The process is nice and straightforwardâ€”the same for Vercel, the company behind NextJS.</p> <p>You can, of course, deploy the Dapp using other providers. In the end, it is a NodeJS-based framework. You will find more info about the deployment of the NextJS apps here: <a href=\"https://nextjs.org/docs/deployment\">Deployment</a>.</p> <h3>What's next?</h3> <p>Check more topics <a href=\"/docs/minter-dapp-introduction.html#more-detailed-docs\">here</a>.</p>","excerpt":"A quick intro to the Elven Tools Dapp - custom Elrond frontend app. You'll learn how to start using it.","publicationDate":"2022-04-23","tags":["minter dapp"],"coverImage":""},{"fileName":"jump-start.html","title":"Jump start","body":"<div class=\"docs-info-box\">Remember that the CLI uses public API endpoints by default. You can switch to the custom ones. Read more how to do this <a href=\"/docs/recipes.html#custom-api-endpoints\">here</a>.</div> <h3>TL;DR</h3> <ol>   <li><code>npm install -g elven-tools</code> -> install the npm library (you would need to have Node configured on the system)</li>   <li><code>elven-tools derive-pem</code> -> provide the seed phrase, the walletKey.pem file will be generated</li>   <li><code>elven-tools deploy nft-minter</code> -> provide all the data. There will be a couple of prompts</li>   <li><code>elven-tools nft-minter issue-collection-token</code> -> provide the name and ticker, be careful. They should be short. The ticker should be capitalized</li>   <li><code>elven-tools nft-minter set-roles</code> -> roles for the issued token</li>   <li><code>elven-tools nft-minter start-minting</code> -> starts the minting. By default, it is paused at start</li>   <li><code>elven-tools nft-minter mint</code> -> mint tokens, provide the amount, be careful. There will be custom limits per address</li> </ol> <p>There is also a video which shows it. So I recommend you to check it out:</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/resGP6a7_34\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <p>   Then you can also initialize the Minter Dapp template by using <code>elven-tools init-dapp</code>.   Check how to start with it here: <a href=\"/docs/how-to-start-with-the-dapp.html\">How to start with the Dapp</a>. </p> <h3>Longer step-by-step guides</h3> <p>The Elven Tools includes the Smart Contract, CLI tool, and Minter Dapp for NFT launches. Every part of it can be used as a separate tool. But the best is to use it all together. You can, of course, use the Smart Contract separately using, for example, erdpy, but the elven-tools cli gives you a lot of simplification with the process. You don't have to think about proper arguments because it will ask you for them. Let's see what the workflow could look like.</p> <p>Let's say that you want to prepare a collection generated randomly from .png layers. You can do this with many tools on the Internet. Btw, please take a look at my <a href=\"https://github.com/juliancwirko/nft-art-maker\">custom solution</a>.</p> <p>In the end, you will have a set of generated images and metadata JSON files corresponding to each. It can look like <code>1.png</code> and <code>1.json</code>. Then you would need to pack them and upload them to the IPFS. The IPFS is the only recommended decentralized hosting on the Elrond chain, at least for now. You can upload the files using for example the <a href=\"https://www.pinata.cloud/\">Pinata</a> or <a href=\"https://nft.storage/\">NFT.storage</a>. When you do that, you will get the CIDs, a <a href=\"https://docs.ipfs.io/concepts/content-addressing/\">content identifier</a> for your assets. With that, we can start using the elven-tools cli. Let's jump to it right now.</p> <p>First of all, you would need to install it globally. You need to set up the <a href=\"https://nodejs.org/en/\">Node</a> environment. The npm tool should be included. Then you would need to install the elven-tools CLI. You can do this by: <code>npm install -g elven-tools</code>.</p> <p>By default, the elven-tools cli will come with pre-configured options. The most important is the chain on which it works. It is set to the 'devnet' and the source of the minter Smart Contract. It is set to the 'main' branch of <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">this</a> repo. So in simple words, you don't have to do any configuration to start with the nft minter Smart Contract on the devnet. I'll show you how to configure it for the other setup later.</p> <p>Let's focus on the devnet and the Smart Contract code from a remote source.</p> <p>What you need to do to start is to run the <code>elven-tools derive-pem</code>. You should have the elven-tools cli installed globally so accessible from everywhere in your env. The best would be to create a separate directory to work with it.</p> <pre><code class=\"language-bash\">elven-tools derive-pem âœ” Enter mnemonic (seed phrase)  â€¦ source crop brown mountain grace imitate cattle rice profit truck small soul castle prize tube spoil such topic code actor venue friend truck alien File saved as walletKey.pem </code></pre> <p>Derive PEM is a command which will take your seed phrase and create the key file for signing every transaction. Without it, you won't be able to use the elven-tools cli. The good thing is that you will need to do this only once. And then run every command in the same directory where the <code>walletKey.pem</code> file will land after running this command.</p> <p><strong>Important</strong>: You need to use the correct wallet. If you want to deploy the smart contract on the devnet, please use the devnet seed phrase and ensure that your wallet has some funds. You can use the faucet in the devnet web wallet to get some fake EGLD for testing.</p> <div class=\"docs-error-box\">Don't share your PEM file with anyone. It is the main key to your walletâ€”the same as the seed phrases. The elven-tools don't send any data to the Internet. It works with it only in your local file system.</div> <p>After you generate the PEM file, you can run all other commands. But remember that your wallet needs funds. Otherwise, it won't work. Each transaction takes fees.</p> <p>Let's walk through the whole process here.</p> <p>The first command will be <code>elven-tools deploy nft-minter</code>. It takes the Smart Contract code from its repository and tries to deploy it on behalf of the user whose walletKey.pem file is generated in this directory. It will ask a couple of questions. Let's explain them here.</p> <pre><code class=\"language-bash\">elven-tools deploy nft-minter âœ” Decide if the contract can be upgraded in the future.  â€º Yes âœ” Decide if the contracts storage can be read by other contracts. Not recommended in this case.  â€º No âœ” Decide if the contract can receive funds. Recommended because of the royalties.  â€º Yes âœ” Provide the base IPFS CID:  â€¦ main_asset_ipfs_cid_here âœ” Provide the base metadata files IPFS CID:  â€¦ main_metadata_ipfs_cid_here âœ” Do you want to attach the metadata JSON file in the Assets/Uris?   (It will be attached and encoded in the attributes anyway, but some marketplaces require that).   â€º Yes âœ” Provide the file extension:  â€º .png âœ” Provide amount of tokens in collection:  â€¦ 10000 âœ” Provide the seling price (ex. 0.5 for 0.5 EGLD):  â€¦ 0.01 âœ” Total tokens limit per one address per whole collection:  â€¦ 6 âœ” Provide the royalties value (ex. 20 for 20%) [optional]:  â€¦ 5 âœ” Provide tags (ex. tag1,tag2,tag3) [optional]:  â€¦ test1,test2 âœ” Provide the provenance hash (sha256 hash of all images) [optional]:  â€¦ optional_provenance_hash_here Deployment transaction executed: success Deployment tx: https://devnet-explorer.elrond.com/transactions/6c78b4f9adbf4e04e84e5ffe8bfed577ee2ad080c039fb3c3db1199c5d1d413c </code></pre> <p>You will be asked one by one. The prompts are helpful. You don't have to worry about proper arguments preparation. The first three questions are about metadata for code. You need to decide if your smart contract should be payable or upgradable. There are hints for that. You can also read about it <a href=\"https://docs.elrond.com/developers/developer-reference/code-metadata/\">here</a>.</p> <p>The following prompt is where you would need to provide your CIDs. It can be a different CID for metadata and images, but it can also be the same CID. It depends on how you store your files in the IPFS.</p> <p>You will also be able to choose if you want your metadata file to be attached in the Assets/Uris next to the Uri for the asset file (like .png). The metadata Uri is encoded in the attributes, but some marketplaces also require it in the Uris array.</p> <p>Then you can also configure the file extension. There are a couple to choose from.</p> <p>After that, you will provide the total amount of tokens in your collection.</p> <p>Next is the selling price. You can use the standard format here. For example, 0.5 is 0.5 EGLD.</p> <p>Then you would need to define how many tokens one address can mint. It is usually used to prevent a big player from buying the almost whole collection. Of course, it doesn't avoid minting on the different addresses, but it is always helpful.</p> <p>Then you can provide the royalties value. Use standard percent here, so 5 is a 5%.</p> <p>Then you can give the tags for the collection, and at the end, you can also provide the <a href=\"https://medium.com/coinmonks/the-elegance-of-the-nft-provenance-hash-solution-823b39f99473\">provenance hash</a>. It will also be queryable later.</p> <p>The following mandatory command which you would use is issuing the collection token. You can do this by running <code>elven-tools nft-minter issue-collection-token</code>. The token will be issued, and all will be saved in the <code>output.json</code> file in the same directory. Here you will be asked about the name of the collection and the ticker. It looks like that:</p> <pre><code class=\"language-bash\">elven-tools nft-minter issue-collection-token âœ” Enter the name for the collection token (ex. MyName123).  Avoid spaces and special characters  â€¦ TestCollectionName âœ” Enter the ticker for the collection token (ex. MYNAME).  Avoid spaces and special characters. Keep it short and capitalize.  â€¦ TCLN â ¼ Processing transaction... Transaction: https://devnet-explorer.elrond.com/transactions/762adbb2485697c5b20a09ca28ff6bd4f0b11238ce57bee99d24c8ebd7a1d826 Your collection token id:  TCLN-416d0e Also saved in the output.json file. </code></pre> <p>The last mandatory command is <code>elven-tools nft-minter set-roles</code>. It will assign the obligatory role, which allows for new NFT tokens creation. Here there won't be any prompts, at least for now. Only a transaction will take the token data from the output.json file and assign the roles.</p> <pre><code class=\"language-bash\">elven-tools nft-minter set-roles Transaction: https://devnet-explorer.elrond.com/transactions/b156ebc9f91a75c56ee5e1ae034c2e4ce09a9de16cde79f297221b457902e326 </code></pre> <p>The following steps can be different on what you want to achieve. You can start minting directly or set up so-called 'drops' where you will define how many tokens will be minted in one drop. You can also always start or pause the minting process. What is necessary is that the contract will always mint randomly in all cases. Let's see how it looks when we want just to start the minting: <code>elven-tools nft-minter start-minting</code> and <code>elven-tools nft-minter mint</code> You will be asked to provide how many tokens you would wish to mint. Remember that the Smart Contract will have limits per one address. See how to check them later in this article.</p> <pre><code class=\"language-bash\">elven-tools nft-minter start-minting âœ” Are you sure that you want to proceed?  â€º Yes â ¼ Processing transaction... Transaction: https://devnet-explorer.elrond.com/transactions/8260437c4a2296169cf7bd925f135223529029ad8e1b3f2b535ee7f07ef3672c  elven-tools nft-minter mint âœ” Provide how many tokens should be minted. Take into account possible limitations set on the Smart Contract (ex 3 for three tokens):  â€¦ 2 âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/15194f779bebc31babdc7711f685a4bf0560c9a0484f6e644a40a1a0ee2f94ef </code></pre> <p>Check out examples of scenarios with all that possibilities: <a href=\"/docs/elven-tools-workflows.html\">Elven Tools workflows</a>.</p> <h3>Good to know</h3> <p>The Elven Tools CLI can list all the available commands for every subcommand. You can do: <code>elven-tools --help</code> or <code>elven-tools nft-minter --help</code>. You can always check the installed version by <code>elven-tools --version</code>.</p> <p>Every step will update the <code>output.json</code> file. So, for example, the Smart Contract address will be put there and the collection token ticker. If you already deployed the Smart Contract without using the Elven Tools CLI, you can always configure it in the <code>.elventoolsrc</code> file using the config: <code>{ \"nftMinterSc\": { \"deployNftMinterSC\": \"&#x3C;sc_address_here>\" } }</code>.</p> <p>Not all the commands trigger a Smart Contract transaction. There are also public queries for the Smart Contract, for example:</p> <pre><code class=\"language-bash\">get-total-tokens-left get-provenance-hash get-drop-tokens-left get-nft-price get-nft-token-id get-nft-token-name get-tokens-limit-per-address-total get-tokens-minted-per-address-total get-tokens-limit-per-address-per-drop get-minted-per-address-per-drop </code></pre> <p>...and more, check <code>elven-tools nft-minter --help</code> for the whole list.</p> <p>With them, you can get simple information written in the Smart Contract. You can also access them through API. Read more about it <a href=\"https://docs.elrond.com/sdk-and-tools/rest-api/virtual-machine/\">here</a>.</p> <p>Elven Tools also provides the Minter Dapp for the NFT launch, which strictly integrates with the Smart Contract. It have a lot of useful widgets.</p> <h3>Where to go from here?</h3> <p>This part of the docs had one purpose: to guide you through the process step by step.</p> <p>From here you can read more detailed docs on:</p> <ul>   <li><a href=\"/docs/recipes.html\">Recipes</a></li>   <li><a href=\"/docs/cli-introduction.html#custom-configuration-options\">CLI configuration options</a></li>   <li><a href=\"/docs/cli-commands.html\">CLI possible commands</a></li>   <li><a href=\"/docs/sc-endpoints.html\">Smart Contract endpoints</a></li> </ul> <p>If you still don't know how to use it, please feel free to contact me on <a href=\"https://twitter.com/JulianCwirko\">Twitter</a> or <a href=\"https://t.me/juliancwirko\">Telegram</a>. You can also write an e-mail to me: julian.cwirko@gmail.com</p>","excerpt":"The Elven Tools includes the Smart Contract, CLI tool, and Minter Dapp for NFT launches. Every part of it can be used as a separate tool.","publicationDate":"2022-01-25","tags":["intro"],"coverImage":""},{"fileName":"minter-dapp-introduction.html","title":"Minter Dapp introduction","body":"<p>Elven Tools Dapp is a template (landing page) with preconfigured logic to be used with the Elven Tools Smart Contract. It is a minter dapp based on the <a href=\"https://nextjs.org/\">NextJS</a> framework, which gives many possibilities for modifications and extending it.</p> <ul>   <li><a href=\"https://github.com/ElvenTools/elven-tools-dapp\">Elven Tools Dapp repository</a></li>   <li><a href=\"https://dapp-demo.elven.tools/\">Elven Tools Dapp live demo</a> (you can mint some NFTs on the devnet here!)</li> </ul> <p>You can use it primarily for this particular case, so for minting NFTs based on Elven Tools Smart Contract, you could also use it as a boilerplate for your other projects. You would only need to do some modifications.</p> <p>Because it is built using the NextJS framework, deployment and hosting with <a href=\"https://vercel.com/\">Vercel</a> or <a href=\"https://www.netlify.com/\">Netlify</a> is as simple as pushing the code to the repository. Also, private repository and not only on GitHub. I will be covering both of these later.</p> <p>Below you'll find the explanation of a couple of choices:</p> <h3>Why NextJS?</h3> <p>There are a couple of reasons. The most important are:</p> <ol>   <li>Based on React, which is well known and most popular</li>   <li>Offers static sites generation or/and server-side rendering. Very important when it comes to landing pages and SEO.</li>   <li>Optimized with the Web Standards in mind. There are many tools for optimizing the assets loading and overall performance.</li>   <li>Simple PWA and Service Workers configuration is essential for optimization.</li>   <li>A lot of plugins and excellent development experience.</li> </ol> <h3>Why not the dapp-core library?</h3> <ol>   <li>It is too complicated for this purpose.</li>   <li>The Dapp should also be helpful as a boilerplate for other projects, so it needs to be simple.</li>   <li>There is more control over auth flows with a custom approach. And this is the core of the dapp, so it is critical.</li>   <li>It has too many utilities that, for this case, won't be used.</li> </ol> <h3>Why the API endpoint is proxied?</h3> <ol>   <li>Allows hiding the API endpoint under the same domain <code>www.your-domain.com/api</code>.</li>   <li>No one will be able to use this endpoint from outside the Dapp.</li>   <li>When used with no public API, You can hide the API keys which need to be attached to the endpoint.</li>   <li>Usage of the public Elrond API is always a bad idea in such a dapp, so it seems to be a perfect solution for third-party providers.</li>   <li>It will still work well with the public Elrond API.</li> </ol> <h3>Why written with Typescript and not JavaScript only?</h3> <ol>   <li>Typescript becomes the standard for JavaScript projects.</li>   <li>Better control over the code.</li>   <li>Better control over bugs.</li>   <li>Smooth refactoring experience.</li> </ol> <h3>Why not use the Redux for state handling?</h3> <ol>   <li>The Redux is a great tool, but it seems to be an overkill in this case.</li>   <li>The Dapp uses <a href=\"https://valtio.pmnd.rs/\">Valtio</a> for global state management, a small yet powerful tool.</li> </ol> <h3>Why Chakra UI?</h3> <ol>   <li>Intuitive configuration.</li>   <li>Excellent approach to the theming.</li>   <li>You can use it almost the same as with utility CSS classes.</li>   <li>Very flexible. You can write CSS in JS in many ways.</li>   <li>A lot of React-specific utilities (Hooks).</li>   <li>Integrates well with Next.</li>   <li>Built with accessibility in mind.</li>   <li>A lot of ready-to-use components.</li> </ol> <h3>Why separate configuration for the Smart Contract data?</h3> <ol>   <li>This is basically for static data such as smart contract address, collection ticker, etc. It is mainly to save the API resources. Otherwise, all users will call the API endpoint a lot of times.</li>   <li>In the future, it will be available as an option. The default behavior would be to query the smart contract with better caching.</li> </ol> <h3>Below, you will find a sneak peek video:</h3> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ATSxD3mD4dc\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>What's next?</h3> <ul>   <li><a href=\"/docs/how-to-start-with-the-dapp.html\">How to start with Elven Tools Dapp - step by step</a></li> </ul> <h3>More detailed docs</h3> <ul>   <li><a href=\"/docs/dapp-structure.html\">Dapp structure</a> - here, you will learn about the essential components of the Dapp</li>   <li>[Soon...] Dapp configuration walkthrough - here, you will learn how to configure the Dapp properly</li>   <li><a href=\"/docs/dapp-deployment.html\">Dapp deployment</a> - here, you will learn how to deploy the Dapp using Netlify or Vercel</li>   <li><a href=\"/docs/dapp-api-proxy.html\">Dapp API proxy</a> - here, you will learn how the API proxy and 'guard' middleware works</li>   <li>[Soon...] Quick intro to Chakra UI and NextJS with links - here, you will learn how to modify the Dapp using included tools like Chakra UI and NextJS</li>   <li><a href=\"/docs/dapp-react-hooks-and-components.html\">Dapp React prebuilt hooks, components, and utilities</a> - here, you will learn about all the custom React hooks and tools which can be used in many different ways</li>   <li><a href=\"/docs/dapp-backend-integration.html\">Dapp backend integration</a> - here you will learn how to extend your dapp and verify the user on the backend side when needed</li>   <li>Other docs will pop up when needed...</li> </ul>","excerpt":"Fully functional and optimized minter dapp based on the Next framework, integrated with Elven Tools Smart Contract.","publicationDate":"2022-04-25","tags":["minter dapp"],"coverImage":""},{"fileName":"recipes.html","title":"Recipes","body":"<p>Here are ready-to-use recipes and more information on real-life use cases.</p> <h3>How to work with the Smart Contract locally</h3> <p>In most cases, it is good to provide some modifications for the final version of the Smart Contract, such as changing the functions' names to make life harder for the bot's owners.</p> <p>It is good to build the Smart Contract locally and deploy it from the file system in such a case. It is possible by default with the Elven Tools CLI. You need to prepare the directory <code>sc/nft-minter</code> in the same place where you already have the <code>walletKey.pem</code> file and later the <code>output.json</code> file. The tree should look like that:</p> <pre><code class=\"language-bash\">. â”œâ”€â”€ output.json â”œâ”€â”€ sc â”‚   â””â”€â”€ nft-minter â”‚       â”œâ”€â”€ elven-nft-minter.abi.json â”‚       â””â”€â”€ elven-nft-minter.wasm â”œâ”€â”€ walletKey.pem </code></pre> <p>As you can see, we have the <code>.abi.json</code> and <code>.wasm</code> files there. You will find them in the <code>output</code> directory after building the Smart Contract locally, and the elven-tools cli tool will take them by default. Remember to only keep the same naming convention for the directories - <code>sc/nft-minter</code>.</p> <p>If you need some help working with the Smart Contract in the Elrond ecosystem, please check docs and my article <a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">here</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/TivnKJsyLH8\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to use the configuration file</h3> <p>The configuration file is optional, and you don't need it until you want to change the chain or the Smart Contract source. Plus, maybe after some modifications, you would like to change the functions names and gas limit. All default values are defined <a href=\"https://github.com/ElvenTools/elven-tools-cli/blob/main/src/config.ts\">here</a>, and below, you'll find the example of how to overwrite them from outside of the lib itself.</p> <p>The configuration file should be named <code>.elventoolsrc,</code> or take any compatible name from the <a href=\"https://github.com/davidtheclark/cosmiconfig\">cosmiconfig</a> project. The main handle should be <code>elventools</code>.</p> <pre><code class=\"language-json\">{     \"chain\": \"testnet\",     \"nftMinterSc\": {         \"version\": \"v1.2.0\",         \"mintFnName\": \"mintMe\"     } } </code></pre> <p>In the example above, we define the chain as the 'testnet' (devnet is set by default), and we also define the version for the Smart Contract, <code>v1.2.0</code> (the last tag name should always be selected as default). It can also be a branch name. Then we also define the new name for the 'mint' function. You can also change names for other functions and set up different gas limits.</p> <p><strong>You will find all possible options <a href=\"/docs/cli-introduction.html#custom-configuration-options\">here</a>.</strong></p> <p>Remember, you don't have to change the <code>config.ts</code> file. It is for library usage. You don't have to clone the repository to change the configuration. <code>.elventoolsrc</code> is the only config file that should be used.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/UlyTVa6oLuM\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>Mainnet deployments</h3> <p><strong>Important!</strong> The same way as in the example above, you can configure deployment to <code>mainnet</code>. Please remember about a couple of things:</p> <ul>   <li>make sure that you derive the walletKey.pem file from the seed from the mainnet wallet. Make sure that the computer you are using is safe, and no one will take the PEM file from you. Or/and seed phrase,</li>   <li>change the <code>chain</code> in the config file to the <code>mainnet</code>,</li>   <li>be careful with Smart Contract versions. By default, the latest version of the CLI will use the newest version of the Smart Contract. Remember that if you have .wasm and .abi files in the <code>sc/nft-minter</code> directory, then they will be used instead of the ones from the repository,</li>   <li>test the whole process 'million' times on the devnet, test with small amounts and big amounts, with multiple wallets as buyers, test queries and transactions, buy to the limits, to test them too,</li>   <li><strong>I can't provide individual support</strong>, but I will always try to help.</li> </ul> <h3>Custom API endpoints</h3> <p>It is always advisable to use the custom API endpoints custom proxies for production-ready apps. Even with this tool, it is better to use the custom one. You can read more about how to set up your architecture <a href=\"https://docs.elrond.com/integrators/observing-squad/\">here</a>.</p> <p>Suppose you don't have the resources to do that. You can find third-party services which do that as a service.</p> <p>To switch to your custom API endpoint, you would need to add in your <code>.elventoolsrc</code> configuration file:</p> <pre><code>{   \"chain\": \"devnet\",   \"apiProviderEndpoint\": \"https://devnet-api.elrond.com\" } </code></pre> <p>It is an example of the default API endpoint for the devnet. You can do the same for the testnet and mainnet.</p> <p>When you need to use the Gateway instead API, you can configure it like that:</p> <pre><code>{   \"chain\": \"devnet\",   \"gatewayProviderEndpoint\": \"https://devnet-gateway.elrond.com\" } </code></pre> <p>It is an example with the default Gateway endpoint for the devnet. You can do the same for the testnet and mainnet.</p> <p>Important! When nothing is provided, the CLI will use the default, public Elrond API endpoint (api.elrond.com, devnet-api.elrond.com, testnet-api.elrond.com). When the <code>gatewayProviderEndpoint</code> is set, it will always overwrite the <code>apiProviderEndpoint</code>.</p> <h3>How to use allowlist</h3> <p>The allowlist is usually required for the first batch of tokens to distribute them only to chosen addresses. It can be a list of eligible addresses.</p> <p>There are three endpoints and commands which help with that. First you would need to have the listof addresses.</p> <p>Then you need a file called <code>allowlist.json</code> in the root directory. It should have the list of addresses in such a form:</p> <pre><code class=\"language-json\">[   \"erd1.......\",   \"erd1.......\",   \"erd1.......\",   \"erd1.......\", ] </code></pre> <p>There should be a maximum of 320 addresses per transaction. You can make a couple of transactions if you need to. But remember to update the file on each.</p> <p>You can populate the list without the file, then the CLI will request it through a prompt where you need to provide them one by one, separated using a comma.</p> <p>Let's see what it looks like in both cases:</p> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter populate-allowlist   Populating addresses from the allowlist.json file:    âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/4a3b63edc1cf00c8025c025926db033964e4625fa5ddcd316b880787f3c8094f </code></pre> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter populate-allowlist   There is no allowlist.json file with the addresses. You will be providing addresses by hand.   âœ” Are you sure that you want to proceed?  â€º Yes âœ” Provide the list of addresses. Max 320 addresses per one transaction. You can add more by sending more transactions. Separate them with comma (\",\"):  â€¦ erd1puseeussfftajfj92ezqtfp0ca6u0s2thu7n64cyw6m37ef8dh0sekwt27, erd18yxxeuf2fkwlwgrnc3chjyf4gl3429qpp5fqynhzf2gn6hs3h8dqu7zt7n Transaction: https://devnet-explorer.elrond.com/transactions/f8bf7de010629e32008bebb1ba5681a008f23afaf949e0e565ea3bbf41bd80fd </code></pre> <p>Remember that you will always need to enable the allowlist after populating it. Otherwise, it will be ignored. You can enable and disable it using: <code>elven-tools nft-minter enable-allowlist</code> and <code>elven-tools nft-minter disable-allowlist</code>.</p> <p>You can also use a couple of SC queries. This allows to get the current size of the allowlist, check if the address is there, or check if the allowlist is enabled. These are:</p> <pre><code>elven-tools nft-minter get-allowlist-size elven-tools nft-minter is-allowlist-enabled elven-tools nft-minter get-allowlist-address-check </code></pre> <p>You will be able to clear the allowlist with:</p> <pre><code>elven-tools nft-minter clear-allowlist </code></pre> <p>It will clear the whole allowlist because the process is quite heavy. The best is to keep max 1300 addresses in the allowlist at a time. Of course, if only you plan to clear it later. If you keep more and want to clear it, you can reach the gas limit for a transaction. So it would be best to split the allowlist per drop, keep it as small as possible and clear it each time.</p> <p>You can also remove a single address by:</p> <pre><code>elven-tools nft-minter remove-allowlist-address </code></pre> <p>Remember that you can always use the functionality without using the CLI tool, then you would need to call the same endpoints. You will find all commands for the CLI <a href=\"/docs/cli-commands.html\">here</a> and all SC endpoints <a href=\"/docs/sc-endpoints.html\">here</a>. Also, check the longer article about <a href=\"/docs/elven-tools-workflows.html\">possible workflows</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/rdg6s7KHFt0\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to use drops</h3> <p>The drops are, in simple words, batches of tokens to mint. You don't have to use them, but it is usually required because most projects usually split the collection into 'waves' of distribution.</p> <p>Now let's see how to define a drop in which we will mint only 2500 of the whole 10k collection. You would need to use <code>elven-tools nft-minter set-drop</code> when using the CLI tool. You will be asked to provide how many tokens per drop it should mint. After that, it will pause the minting process. You can also pause the minting at any time you want by <code>elven-tools nft-minter pause-minting</code>. You can also unset the drop by <code>elven-tools nft-minter unset-drop</code>. You'll find all the commands <a href=\"/docs/cli-commands.html\">here</a>.</p> <p>Example:</p> <pre><code class=\"language-bash\">elven-tools nft-minter set-drop âœ” Provide the amount of the tokens for the drop:  â€¦ 2500 Transaction: https://devnet-explorer.elrond.com/transactions/915a9b115d01dbc0026e91ab889284018bd51cee8a030804dbb5da600c1bdd25  elven-tools nft-minter mint âœ” Provide how many tokens should be minted. Take into account possible limitations set on the Smart Contract (ex 3 for three tokens):  â€¦ 2 âœ” Are you sure that you want to proceed?  â€º Yes Transaction: https://devnet-explorer.elrond.com/transactions/8954262fea15e63705d696fcfeb92874a4c10239703b5a6631fd7f989c494ba8 </code></pre> <p>There are also SC queries that allow checking a couple of things. These are:</p> <pre><code>elven-tools nft-minter get-drop-tokens-left elven-tools nft-minter get-minted-per-address-per-drop elven-tools nft-minter get-tokens-limit-per-address-per-drop elven-tools nft-minter is-drop-active </code></pre> <p>They are self-explanatory, but you will find all descriptions under the links below.</p> <p>Remember that you can always use the functionality without using the CLI tool, then you would need to call the same endpoints. You will find all commands for the CLI <a href=\"/docs/cli-commands.html\">here</a> and all SC endpoints <a href=\"/docs/sc-endpoints.html\">here</a>. Also, check the longer article about <a href=\"/docs/elven-tools-workflows.html\">possible workflows</a>.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZERCb-c-BP4\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to use the giveaway</h3> <p>The <code>giveaway</code> functionality is helpful when you want to give some tokens to a particular address. It can be because they are the team members or someone you want to thank. Remember that with Elven Tools, you can choose the specific token. It will still be randomly selected and minted. When using this functionality, there is no paymentâ€”only transaction fees.</p> <p>You can give some tokens using the CLI's command <code>elven-tools nft-minter giveaway</code>. You would need to provide the address to which you would like to send the NFTs and the amount of the tokens to give.</p> <p>You can use this even when the minting process is paused, which is usable for the giveaway before the official minting is started.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/WH7kl3s7gdw\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <h3>How to claim dev rewards</h3> <p>In the Elrond ecosystem, each Smart Contract will get the share of the fees as a development reward. So the developer of the contract will get some share because this is an open source Smart Contract. It will generate these rewards for everyone who deploys it. You can claim them by using: <code>elven-tools nft-minter claim-dev-rewards</code>. Remember that this will only work for the owner of the Smart Contract.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <h3>How to claim royalties and other funds</h3> <p>The Smart Contract is payable by default, so in theory, it is possible to transfer EGLD funds to its address. By definition, this is how marketplaces should send the royalties. There is an <code>elven-tools nft-minter claim-sc-funds</code>, which will allow getting all the funds locked on the contract. Of course, only for the owner of the contract.</p> <p>There will also be a dedicated endpoint/command which will call the marketplaces Smart Contracts to claim the royalties because not all of them will send them automatically.</p> <p>As always, you can call the giveaway endpoint without the CLI. Check them in the SC endpoints section.</p> <h3>How to get owners addresses using the collection ticker</h3> <p>From version 1.6.0 there is additional command <code>elven-tools collection-nft-owners</code>. It will allow getting owners' addresses, using only the collection ticker. It is useful, for example, when you want to do some promotional giveaway. The functionality will save the addresses in the <code>nft-collection-owners.json</code> where the command is triggered.</p> <p>Additionally, you can also filter by metadata JSON file name. It is an optional step.</p> <p><strong>Important</strong>: It will work only with the API endpoint, not the gateway. Elven Tools CLI, by default, uses the API endpoint. So it should work by default, but you need to remember that.</p> <p>How to use it? You need to use at least version 1.6.0 of the CLI. You can check it by <code>elven-tools -v</code>, and you would need to use the command <code>elven-tools collection-nft-owners</code>. Then there are prompts. You would need to provide the collection ticker and answer two questions about whether you want to filter smart contract addresses.</p> <p>Because of how the API works, we need to do calls with a max size of 100 items. Here we also have calls that are limited to 5 per second. You can change this limit in the configuration file. Check how <a href=\"/docs/cli-introduction#custom-configuration-options\">here</a>. If you need to change this setting, in the config file, there should be an entry:</p> <pre><code>{   \"chain\": \"mainnet\",   \"collectionNftOwners\": {     \"apiCallsPerSecond\": 5   } } </code></pre> <p>When is the address not unique? It is when one address will have more than one NFT token from the collection. See the example below:</p> <pre><code>elven-tools collection-nft-owners âœ” Provide the collection ticker  â€¦ EAPES-8f3c1f âœ” Do you want to exclude smart contract addresses?  â€º Yes âœ” Do you want to filter by metadata JSON file name? Provide names without the extension separated by a comma (example: 123,555,9999) [you can ommit that, just confirm empty]  â€¦  There are 10000 tokens in that collection. Done, 1042 addresses saved. Without smart contract addresses. </code></pre> <div class=\"embeded-media-container\">   <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/4vM_y25uaq8\" title=\"YouTube video player\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe> </div> <p><strong>You can also do filtering by metadata JSON filename:</strong></p> <pre><code>elven-tools collection-nft-owners  âœ” Provide the collection ticker  â€¦ EGG-6ee076 âœ” Do you want to include only unique addresses?  â€º No âœ” Do you want to exclude smart contract addresses?  â€º No âœ” Do you want to filter by metadata JSON file name? Provide names without the extension separated by a comma (example: 123,555,9999) [you can ommit that, just press enter]  â€¦ 1390,827  There is 1000 tokens in that collection. Done, 2 addresses saved. </code></pre> <p>If you are interested in generating a <strong>CSV</strong> file, you can use the <a href=\"https://github.com/ElvenTools/elven-tools-collection-owners-csv\">elven-tools-collection-owners-csv</a> script, which will do that. The input file is the output of the <code>elven-tools collection-nft-owners</code>. You'll find the input and output examples in the <a href=\"https://github.com/ElvenTools/elven-tools-collection-owners-csv/tree/main/data\">data</a> folder.</p> <h3>CLI for a buyer</h3> <p>You can also use the CLI tool when you are only a buyer, not an owner of the Smart Contract. To do so, you would need to go through 4 steps.</p> <ol>   <li>Install the CLI: <code>npm install elven-tools -g</code></li>   <li>Derive the PEM file of your wallet: <code>elven-tools derive-pem</code> You would need to pass your seed phrase here. No worries, you work on your computer. If it is safe, nothing leaves it because of the CLI too. Never share seed phrases and PEM files with anyone.</li>   <li>Create a configuration file in the same directory as the generated walletKey.pem file. The configuration file should be named <code>.elventoolsrc</code>. Inside add:</li> </ol> <pre><code>{   \"nftMinterSc\": {     \"deployNftMinterSC\": \"&#x3C;nft_minter_smart_contract_address_here>\",     \"tokenSelingPrice\": \"&#x3C;price_of_the_nft_here>\"   } } </code></pre> <p>You would need only these two settings to be able to buy. Of course, the contract owner should prepare everything and start the minting process.</p> <p>   The <code>tokenSelingPrice</code> here is a format with 18 zeros. So 1 EGLD is 1000000000000000000.   The <code>deployNftMinterSC</code> here is an address of the contract. The owner should share it. </p> <ol start=\"4\">   <li>The last would be to call the mint command: <code>elven-tools nft-minter mint</code>. You will be asked about the number of tokens to mint. There will be limits. You would know them. You can <a href=\"/docs/sc-endpoints.html#smart-contract-queries\">query the contract to check them</a>.</li> </ol> <h3>What is an output.json file</h3> <p>The <code>output.json</code> file will be created as temporary storage, which keeps the created Smart Contract address, the information about the collection token, and the token price. It is required in further operations. This file is created automatically when deploying the Smart Contract using the CLI. So it is mostly there for the owner of the Smart Contract. It looks like that:</p> <pre><code class=\"language-json\">{   \"nftMinterScAddress\": \"erd1qqqqqqqqqqqqqpgq7a0cq90r2kqymtaqysxp7umrcyp04jgmgtkscelhmp\",   \"nftMinterScCollectionSellingPrice\": \"1000000000000000\" } </code></pre> <p>You don't have to think about it much.</p> <h3>Why do we need the shuffle endpoint</h3> <p>The endpoint will set the following index to mint. It is important here that it will randomly select it from the indexes left to mint. This endpoint is also public, so everyone can call the transaction and change the following index to mint. It assures that the process is random, and everyone can impact that.</p> <p>When using the CLI you can always run <code>elven-tools nft-minter shuffle</code>.</p>","excerpt":"The Elven Tools includes the Smart Contract, CLI tool, and Minter Dapp for NFT launches. Every part of it can be used as a separate tool.","publicationDate":"2022-01-25","tags":["intro"],"coverImage":""},{"fileName":"sc-endpoints.html","title":"SC Endpoints","body":"<p>Below you'll find all endpoints with a short description. You can always see the complete code <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc\">here</a>.</p> <p>Please check all attributes for each endpoint in the linked code line in the repository. It is all open-source.</p> <p>You'll find all the endpoints here: <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/blob/main/src/lib.rs\">lib.rs</a>.</p> <h3>Setup endpoints</h3> <p>These are the required operations you would need to perform once always when configuring a new collection and Smart Contract. Check the CLI tool to simplify the work required.</p> <ul>   <li><code>init</code> - standard init endpoint, it will be triggered on deployment and upgrade</li>   <li><code>issueToken</code> - required endpoint for creating a new collection, this is done once, and the token is one for one smart contract instance. It is a handler for the whole collection.</li>   <li><code>setLocalRoles</code> - Set roles set only one role for now. The required one for creating the NFTs.</li>   <li><code>startMinting</code> - You will need to start the minting process after deploying the contract and each time you use the pauseMinting function</li> </ul> <h3>Only owner endpoints</h3> <p>Only the owner of the Smart Contract can call them. In such a Smart Contract, there are quite a lot of them. Some of them are mandatory for the initial Smart Contract setup. See above. To keep everything in order, they are also copied here.</p> <ul>   <li><code>init</code> - standard init endpoint, it will be triggered on deployment and upgrade</li>   <li><code>issueToken</code> - required endpoint for creating a new collection, this is done once, and the token is one for one smart contract instance. It is a handler for the whole collection.</li>   <li><code>setLocalRoles</code> - Set roles set only one role for now. The required one for creating the NFTs.</li>   <li><code>pauseMinting</code> - You can pause the minting process in any moment you need.</li>   <li><code>startMinting</code> - You will need to start the minting process after deploying the contract and each time you use the pauseMinting function</li>   <li><code>setDrop</code> - You can set the 'drop' by defining how many tokens per drop will be minted</li>   <li><code>unsetDrop</code> - You can unset the drop in any time. Minting will continue without limits.</li>   <li><code>setNewPrice</code> - You can change the price for each NFT at any time. The best is to do this when configuring the next drop.</li>   <li><code>changeBaseCids</code> - You can change the CIDs for images and metadata, but only when there is no NFTs minted yet. Otherwise, it doesn't make sense because the collection will be unsynchronized.</li>   <li><code>setNewTokensLimitPerAddress</code> - You can change the limit of tokens per single address in any given time.</li>   <li><code>giveaway</code> - You can organize the giveaway by providing the address and amount of tokens to send. It will mint and send tokens without the payment.</li>   <li><code>claimScFunds</code> - You can claim the funds which are there on the payable Smart Contract. For example, royalties paid by marketplaces. These are only funds that come from outside. The funds from minting are directly sent to the contract owner after each mint.</li>   <li><code>populateAllowlist</code> - You can set up the allowlist by populating the storage with addresses. Keep 320 addresses as max per one transaction. Otherwise, it could reach the max gas limit.</li>   <li><code>enableAllowlist</code> - You can enable to allowlist. Only then will it work. Remember about that.</li>   <li><code>disableAllowlist</code> - Tou can disable the allowlist and keep standard minting functionality</li>   <li><code>clearAllowlist</code> - It will clear the whole allowlist. The best is to keep a max of 1300 addresses in the allowlist at a time. Of course, if only you plan to clear it later. If you keep more and want to clear it, you can reach the gas limit for a transaction. So it would be best to split the allowlist per drop, keep it as small as possible and clear it each time.</li>   <li><code>removeAllowlistAddress</code> - removes a single address from allowlist</li> </ul> <h3>Endpoints for all</h3> <ul>   <li><code>mint</code> - The main mint/buy function. The smart contract works like a candy machine. You pay, and it randomly mints the NFT for you. Then it sends it into your wallet. The NFTs on the Elrond network are ESDT standardized tokens.</li>   <li><code>shuffle</code> - To be more transparent, the Smart Contract has a public endpoint that allows everyone to trigger the shuffling mechanism which is also triggered after every mint. This additional functionality ensures that the process is random, and anyone can set the following index.</li> </ul> <h3>Smart Contract queries (also for all, by design)</h3> <ul>   <li><code>getDropTokensLeft</code> - This query will return the tokens left for the active drop.</li>   <li><code>getTotalTokensLeft</code> - This query will return total amount of tokens left to mint</li>   <li><code>getNftTokenId</code> - This query will return the collection token ticker</li>   <li><code>getNftTokenName</code> - This query will return the name for NFTs</li>   <li><code>getCollectionTokenName</code> - This query will return the collection token name</li>   <li><code>getNftPrice</code> - This query will return the price for a single NFT</li>   <li><code>getTokensLimitPerAddressTotal</code> - This query will return the limit of tokens for a single address as total for the whole collection</li>   <li><code>getMintedPerAddressTotal</code> - This query will return tokens already minted per single address as total for the whole collection</li>   <li><code>getTokensLimitPerAddressPerDrop</code> - This query will return the limit of tokens for a single address per drop</li>   <li><code>getMintedPerAddressPerDrop</code> - This query will return tokens already minted per single address per drop</li>   <li><code>getProvenanceHash</code> - This query will show the provenance hash if provided.</li>   <li><code>getAllowlistAddressCheck</code> - This query will check if the provided address is on the allowlist.</li>   <li><code>getAllowlistSize</code> - This is mainly to check if the allowlist has the correct size after populating it with addresses.</li>   <li><code>isAllowlistEnabled</code> - This is an important check to ensure that the allowlist is enabled. Only then will it work.</li>   <li><code>isDropActive</code> - This is for checking if there is currently a drop active.</li>   <li><code>getTotalSupply</code> - This is for checking the total supply</li>   <li><code>getTotalSupplyOfCurrentDrop</code> - This is for checking the supply of the current drop</li>   <li><code>isMintingPaused</code> - This is for checking if the minting process is now paused</li> </ul> <h3>How to interact with endpoints</h3> <p>The simplest way is to use the Elven Tools CLI, check how in the <a href=\"/docs/jump-start.html\">Jump start</a> article or the <a href=\"/docs/cli-introduction.html\">CLI introduction</a>.</p> <p>If you don't want to use the CLI, you need to do the queries and transaction calls using the <a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs\">erdjs SDK</a> or <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy/\">erdpy</a>.</p> <p>Check the examples for <code>erdjs</code>:</p> <ul>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs#creating-smart-contract-transactions\">Smart Contract transaction</a></li>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdjs#querying-smart-contracts\">Smart Contract query</a></li> </ul> <p>You can also check the <a href=\"https://github.com/ElvenTools/elven-tools-cli\">elven-tools-cli</a> source code, where I also used the erdjs SDK.</p> <p>Check the examples for <code>erdpy</code>:</p> <ul>   <li><a href=\"https://github.com/ElrondNetwork/elrond-sdk-erdpy/blob/main/erdpy/CLI.md\">Command Line Interface</a></li>   <li><a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">Blog post with usage examples</a></li> </ul>","excerpt":"Below you'll find all endpoints with a short description. You can always see the complete code.","publicationDate":"2022-01-24","tags":["smart contract"],"coverImage":""},{"fileName":"sc-introduction.html","title":"SC Introduction","body":"<p>NFT minter Smart Contract v1</p> <div class=\"docs-info-box\">Be aware that the Smart Contract doesn't have any audits. It has complete functionality for the first version, but it is still needs some improvements. Test it first on the devnet/testnet.</div> <p>You are reading about the Smart Contract designed for the Elrond blockchain. Its primary purpose is to provide a simple logic for minting and buying NFT tokens from a previously configured collection. It does it in a randomized way.</p> <h3>Version 1 supports</h3> <ul>   <li>issuing the collection token</li>   <li>setting the create role</li>   <li>pausing/unpausing the process</li>   <li>random mint and distribution</li>   <li>minting multiple NFTs in one transaction</li>   <li>giveaway options</li>   <li>possibility to split the process into drops/waves</li>   <li>claiming the developer rewards</li>   <li>changing basic setup where it is possible</li> </ul> <p>The smart contract works like a candy machine. In short, the user can pay in EGLD and, in return, will get randomly minted tokens from the previously configured collection. The amount of tokens per address is configured on the smart contract.</p> <h3>Required initial configuration</h3> <p>All are mandatory operations and should be done only once. Make the transactions in this order.</p> <ol>   <li>The Smart Contract requires initial configuration to start the minting process. First, you would need to deploy it with all the arguments defined for the <code>init</code> endpoint. Check the description and link to the code in the <a href=\"/docs/sc-endpoints.html\">endpoints section</a>. It is simpler if you are using the <a href=\"/docs/cli-introduction.html\">Elven Tools CLI</a>.</li>   <li>You would need to issue the collection token using the <code>issueCollection</code> endpoint. With CLI, it is simpler to do that. Again, check it in the endpoints section.</li>   <li>Next is the <code>setLocalRoles</code> endpoint - it is required to set up proper roles for the collection token.</li>   <li>Finally, you need to start the minting by calling the <code>startMinting</code> endpoint. By default, in the beginning, the minting is paused.</li> </ol> <p><strong>Remember that everything is more straightforward with the Elven Tools CLI</strong> Check the <a href=\"/docs/jump-start.html\">jump start section</a>.</p> <h3>Ways of using it</h3> <p>The best way of using it will be with <a href=\"/docs/cli-introduction.html\">Elven Tools CLI tool</a>. It has a lot of valuable functions integrated with the smart contract, so deploying or interacting is simple. You can deploy the smart contract directly from its repository. Almost no coding skills are required in this case.</p> <p>You can also take a more standard path and use <a href=\"https://docs.elrond.com/sdk-and-tools/erdpy/erdpy/\">erdpy</a> for that. Erdpy is an official CLI SDK for Elrond blockchain based on Python. For more information, check the <a href=\"https://www.julian.io/articles/elrond-smart-contracts.html\">blog post</a>.</p> <h3>Limitations and caveats</h3> <ul>   <li>Remember that it is most likely that because of the open-source nature of this Smart Contract, it won't be used only in a way that everyone would want to, be aware that you can always change the names of the endpoints in the Smart Contract. You can even deploy a couple of them. In the last minutes before the mint decide to use one of them. This will limit the bots. Remember always to inform which one is the official one.</li>   <li>Smart Contract in version 1 doesn't have many mechanisms which will strongly limit unwanted behaviors. It only implements random minting, but in version 2, there will be more mechanisms for fair launches.</li> </ul> <h3>Issues and ideas</h3> <p>Please post issues and ideas <a href=\"https://github.com/ElvenTools/elven-nft-minter-sc/issues\">here</a>.</p> <h3>Contact</h3> <ul>   <li><a href=\"https://t.me/juliancwirko\">Telegram</a></li>   <li><a href=\"https://twitter.com/JulianCwirko\">Twitter</a></li>   <li>julian.cwirko@gmail.com</li> </ul> <div class=\"next-page-link\">Next: <a href=\"/docs/sc-endpoints.html\">SC endpoints review</a></div>","excerpt":"You are reading about the Smart Contract designed for the Elrond blockchain. Its primary purpose is to provide a simple logic for minting and buying NFT tokens","publicationDate":"2022-01-25","tags":["smart contract"],"coverImage":""},{"fileName":"tips-on-buying-nfts-on-the-elrond-blockchain.html","title":"Tips on buying NFTs on the Elrond blockchain","body":"<p>There are a couple of things that you should check when you are buying the NFTs on the Elrond blockchain. And a couple of differences in comparison to other chains. I don't want to focus on the supply and demand aspect because you should always do your own research before buying anything. I want to focus on the technological and communication-like elements here.</p> <h3>What we will tackle in the article:</h3> <ol>   <li>Minting through the Smart Contract. How is it done?</li>   <li>The Smart Contracts on the Elrond blockchain are upgradeable by default.</li>   <li>Collection ticker and how to verify it.</li>   <li>Project website with the roadmap and people behind it.</li>   <li>Utility over 'art' unless not randomly generated.</li> </ol> <p>Remember, these are just my opinions. You can always disagree, and I will like to see your point of view.</p> <h3>Minting through the Smart Contract. How is it done?</h3> <p>Elrond blockchain treats the NFTs as native ESDT tokens with additional metadata, so it isn't required to have the Smart Contract to own them. And it isn't even needed to have a Smart Contract to mint them.</p> <p>Still, the minting process and distribution should be done using a Smart Contract because this is fair and trustworthy. The Smart Contract is a mediator between your EGLD and the NFT, which should be sent to you. Otherwise, some third-party wallet will be doing that, and in such a case, we need to trust the third party. So it is not a decentralized process.</p> <p>The best would be to see the Smart Contract's code or at least be able to verify if the Smart Contract is the official one. Most projects will probably not show the Smart Contract's source code, and I understand it. But still, I think it would be possible to prepare the hash of a currently compiled Smart Contract's code and publish it in all communication channels. This way, the user will also know if the contract was upgraded or not. And if the team communicated it properly before taking action.</p> <p>There are a couple of ways to prepare the minting and distribution process. All of them have pros and cons.</p> <p><strong>Let's take a look at two of them in the context of the Elrond blockchain:</strong></p> <ul>   <li>'Candy machine'</li>   <li>'Raffle'</li> </ul> <p>The candy machine's method of minting works like a candy machine (surprise, surprise). The Smart Contract is usually preconfigured to manage the minting process. The buyer sends the amount of EGLD defined on the Smart Contract, and in exchange, they will get randomly minted NFT on their wallet. It is a relatively straightforward way of doing that, and it is ok. Its main pros are simplicity and transparent rules, so the buyers are not confused. They pay, and they see it on the wallet. It is also simpler to set up and maintain, and because of randomization in the minting process, even with automated scripts, it will be hard to snipe the best NFTs. In most cases, this is the way the projects mint.</p> <p>The candy machine has its cons. The most important one is that when you want to mint in some batches spread in time, the first couple of NFTs will reveal the assets. At least in the Elrond ecosystem, it won't be possible to send the NFT and then change its assets URIs. The only option would be to upload the assets to the IPFS later, but this is a poor experience.</p> <p>Is it a big problem? Some would say that even better because these NFTs can influence the price, and with the second batch of minting, the operator will know better what a new price should be for the next official drop. If the first 1000 NFTs are doing great on the secondary market and the price is high. Then the subsequent official minting can be better marketed, and the price can be managed better.</p> <p>Other cons of the candy machine way of minting are that it is more prone to automated bots, and also, people from many different time zones will probably not have a chance to take part.</p> <p>There are a couple of solutions to these concerns. One would be not to send the tokens right away but to keep them and let the people claim them later after the whole collection is minted. Like with everything, this can be done with hybrid approaches, but most likely, it will be a Raffle minting process. Let's see how it could work on the Elrond blockchain and what the ideas are for it.</p> <p><strong>The Raffle can work in two ways:</strong></p> <ul>   <li>Locked EGLD as the ticket in a lottery</li>   <li>SFT (Semi Fungible Token) as the ticket in a lottery</li> </ul> <p>The simplest way would be to use EGLD and save all the addresses in the initial 'bidding/buying' phase. Such a phase can be spread in time. For example, it can be 48h long to allow all the people worldwide to participate. Then after some time, the operator can start the randomized claiming process, which will choose the winners. The winners will be able to claim the NFTs, and the losers will take back their EGLD.</p> <p>The problem of revealing the assets will still be here unless the Smart Contract will keep the winning tickets till the end of the minting of the whole collection. This can be done so that winning addresses are moved to allowlist, and losing addresses can claim back their EGLD immediately after each batch of minting.</p> <p>There is also a more entertaining way of doing that, incorporating the SFTs. Each SFT can look the same, for example, an egg for the dragons or a construction pack for robots, whatever you choose. Then each egg can be claimed after each batch of minting. So the winning addresses will also have something immediately, but not the real NFT yet. They can even sell these SFTs on the secondary market, similar to the candy machine incentive, but you don't operate on the real NFT.</p> <p>Why sell the SFT on the secondary market? Because the owner will be able to swap it for the real NFT when the time is right. Remember that the operator should also correctly communicate it.</p> <h3>The Smart Contracts on the Elrond blockchain are upgradeable by default.</h3> <p>It is worth mentioning that the Smart Contracts on the Elrond blockchain are by default upgradeable (and this is not only Elrond's specific case). What does it mean? It means that the operator can change the logic on the smart contract at every moment, even when the minting process is ongoing. In most cases, it is good because they will react quickly in case of bugs, and probably this is the way it will always work. But remember that it can also be used in a way that is not good for the participants. For example, some scam projects can release a proper Smart Contract, but then after the funds are on it, they can change its code and block all the funds.</p> <p>Ok, so what should you do with this kind of knowledge as a buyer? In most cases, projects won't show the Smart Contract's code anyway. So the best you can do is know about such possibilities and check how the project communicates them. Will they talk about changes or rather keep them in secret. It is why some kind of validation of the Smart Contracts is required, as I wrote before.</p> <p>What can the project do to gain more trust? I will write more about the community's communication later, but how it is appropriately managed is through multisig. So there should be more than one person on the team to be able to upgrade the contract. There should be a requirement for multiple keys to authorize such a transaction. But let's be honest, the minting Smart Contracts and projects around them are usually relatively small, and probably no one will use that. Still, it is worth knowing about it, and it will be a perfect point in the marketing of a project.</p> <p>How to check if a Smart Contract is upgradable or not? When you go to the Elrond Explorer and search for the project's Smart Contract, you will be able to see a badge. For example, let's take randomly one of the Smart Contracts on the mainnet: <a href=\"https://explorer.elrond.com/accounts/erd1qqqqqqqqqqqqqpgqxwakt2g7u9atsnr03gqcgmhcv38pt7mkd94q6shuwt\">explorer.elrond.com/accounts/erd1qqqqqqqqqqqqqpgqxwakt2g7u9atsnr03gqcgmhcv38pt7mkd94q6shuwt</a>. There is a badge <code>UPGRADEABLE</code> under the properties section.</p> <h3>Collection ticker and how to verify it.</h3> <p>On the Elrond blockchain, you would need to issue a collection token with a ticker in a short format, such as <code>ABCD-1a2e3</code>. It is an identifier for the NFT collection. For example, you can always check it in the Elrond Explorer, <a href=\"https://explorer.elrond.com/collections/EGIRL-443b95\">explorer.elrond.com/collections/EGIRL-443b95</a>.</p> <p>What is important here is that the project should always clearly communicate the official and only legit collection ticker. Because many scams will try to copy the collection, educating the buyers about that is always essential.</p> <p>   How will I check the collection ticker when I only have one NFT in my wallet?   Each NFT will get a ticker that starts with the collection id first. So in the case of our example from above, the <code>EGIRL-443b95-0d8b</code> is a particular NFT ticker/id, so as you can see, the <code>EGIRL-443b95</code> prefix here is our collection id from the example. This way, you can always verify if this particular NFT comes from an actual collection and not a scammy one. </p> <h3>Project website with the roadmap and people behind it.</h3> <p>Let's get into less technical and more communication-related topics. What is essential for me when I see the project is its website. It should be clean with good UI, and what is most important is that it should clearly describe the team and the vision. Most of the projects have only the Discord channel, but I don't find it professional. It is, of course, only my opinion and of course, having the Discord server isn't bad at all.</p> <p>When I enter such a website, I would like to see the official collection ticker/id and the Smart Contract address. Of course, it isn't always possible because it depends on the process. Maybe there isn't a collection and Smart Contract yet, but I would like to get it when the process starts.</p> <p>The team and roadmap are also critical. I saw that there are usually team members listed but nothing about them. They are just avatars with some nicknames. I think it is terrible, but of course, it is always good to be anonymous and earn some money ;)</p> <h3>Utility over 'art' unless not randomly generated.</h3> <p>I am not an artist, and I know nothing about art. But when we talk about randomly generated NFTs, it is for sure not about the art. I mean, maybe it is in some rare cases, but let's be honest, most of them are not even pretty ;)</p> <p>It is not a problem at all because, in my opinion, it isn't their primary purpose. Knowing something more than the price is good if you want to get involved in a randomly generated avatar-like collection. There should be a utility to having such an NFT in your wallet. There are a couple of such use cases. Let's list a couple of them in general without specific examples and descriptions. You will find a lot about them on the Internet:</p> <ul>   <li>NFT projects for the e-commerce industry.</li>   <li>NFT projects for the gaming industry.</li>   <li>NFT projects for the music industry.</li>   <li>NFT projects for the medical industry.</li>   <li>NFT projects for the real estate industry.</li>   <li>NFT for academics and schools.</li>   <li>NFT projects involved in charity.</li>   <li>NFT projects for the VR/Metaverse.</li>   <li>NFT as tickets.</li>   <li>NFT in sports.</li>   <li>NFT as the id and community platform access.</li> </ul> <p>The list can probably go a lot further. There are many use cases, but we are all early, and it has to settle down a little bit. I intend to indicate that you should always look deeper and buy some good projects. Unless you are an NFT flipper, then buy everything as fast as you can ;) But I am not interested in such an activity.</p> <h3>Summary</h3> <p>Hopefully, I explained a couple of the most important things when someone is interested in some NFT project on the Elrond Blockchain, but not only on the Elrond. Some of the guides are pretty universal.</p> <p>Be aware that these are only my opinions. I am primarily a developer, so I'm not an expert in marketing, selling, and promoting stuff. I wrote from a developer's perspective and a person who would like to buy some NFTs at some moment in time.</p> <p>   <a href=\"/about.html\">Contact me!</a>   Follow me on <a href=\"https://github.com/juliancwirko\">GitHub</a> and <a href=\"https://twitter.com/JulianCwirko\">Twitter</a>. </p>","excerpt":"There are a couple of things that you should check when you are buying the NFTs on the Elrond blockchain. And a couple of differences in comparison with other chains.","publicationDate":"2022-01-25","tags":["articles"],"coverImage":""},{"fileName":"use-of-ipfs-in-the-elrond-nft-ecosystem.html","title":"Use of IPFS in the Elrond NFT ecosystem","body":"<p>IPFS storage is a crucial part of every NFT ecosystem, not only the Elrond. I found that there is a lot of misunderstanding about why it is required and how it works. I won't describe the IPFS in detail, and it doesn't make sense because there are many excellent articles about it on the Internet that I am about to link. What I would like to do is to explain the basics in the context of Elrond NFTs.</p> <h3>What we will tackle here:</h3> <ul>   <li>IPFS basic intro.     <ul>       <li>Why is IPFS required?</li>       <li>How are the files handled?</li>       <li>What is a CID?</li>       <li>Pinning, why it is essential?</li>       <li>What is an IPFS gateway?</li>       <li>Where can I learn more about IPFS?</li>     </ul>   </li>   <li>How is it used in the Elrond ecosystem?</li>   <li>Helpful IPFS services and tools.</li> </ul> <h3>IPFS basic intro.</h3> <p>The InterPlanetary File System is a peer-to-peer hypermedia protocol. It allows storing and accessing data in a decentralized and trustless way. You are the owner of your data stored on many different nodes located in various places in the world. It can be an image, website, or any other data.</p> <p><strong>Why is IPFS required?</strong></p> <p>It is essential to have decentralized storage for the assets of your NFT token. The assets can't be stored on-chain for the main reason: the size and cost of keeping it on-chain. When using IPFS, you are not dependent on centralized corporations like Amazon, Microsoft, or Google to store your assets (images, movies, music). You don't want your NFT token to depend on a third-party company, even if it is only assets hosting. On-chain metadata, plus assets hosted in a decentralized way, seems like an obvious way of doing that.</p> <p><strong>How are the files handled?</strong></p> <p>One of the main concepts of the IPFS is content addressing. In the IPFS network, the identifier of the content is built based on the content, not the location. You can't change the address of the same content. It is possible, for example, using AWS, where you can change addresses to the same content by changing the domain name, etc. We don't want that for our NFTs because someone could move the assets somewhere else and change the address to them. Then the metadata information on-chain would be wrong, and the saved URL would not show the asset.</p> <p>When someone changes the content on the IPFS, it will get a different identifier and, in fact, always a different address. The old content can't be changed, deleted, or moved. So this is ideal. Our saved URL on-chain will always point to the same asset on the IPFS.</p> <p>You can learn a lot more about the topic here:</p> <ul>   <li><a href=\"https://proto.school/content-addressing\">proto.school/content-addressing</a>.</li>   <li><a href=\"https://docs.ipfs.io/concepts/how-ipfs-works/#content-addressing\">docs.ipfs.io/concepts/how-ipfs-works/#content-addressing</a></li> </ul> <p>Ok, so how the address/url to such content looks. Let's jump to the next topic from the list.</p> <p><strong>What is a CID?</strong></p> <p>The CID (Content Identifier) is a foundation of the content address on the IPFS. It doesn't tell where the content is located, but it defines the content. For example, it could be built based on one image or the directory of images. The main concept is that the CID will be different when anything is changed.</p> <p>The final CID form depends on the content and not on its size. It is a cryptographic hash of the content. The CID helps to find the nearest source of our content. This way, we will be able to get it from one of many nodes/peers in the network which could store it.</p> <p>Ok, let's not dig deeper because these topics are complex. I will leave links where you will find more information.</p> <p>To sum up. It is worth remembering that it is the main and the only identifier we need to locate our content.</p> <p>Read more about the CIDs here:</p> <ul>   <li><a href=\"https://proto.school/anatomy-of-a-cid\">proto.school/anatomy-of-a-cid</a></li>   <li><a href=\"https://docs.ipfs.io/concepts/content-addressing/#identifier-formats\">docs.ipfs.io/concepts/content-addressing/#identifier-formats</a></li> </ul> <p>Let's jump to the next crucial topic.</p> <p><strong>Pinning, why it is essential?</strong></p> <p>Pinning in the IPFS world is comparable to pinging some service to keep it 'alive'. It is very similar. The content on the IPFS network isn't stored forever if it isn't needed anymore. There are special 'garbage collector' services that will remove the contents which are not needed anymore. And what does it mean? It means that there have been no requests for such content since the last request, so that nodes won't store it anymore.</p> <p>An IPFS node can protect data from garbage collection using a so-called pinning service. Of course, you could run your node locally and pin the data, but usually, it is done by using a third-party service that runs many nodes and can provide pinning for you. I will focus on two of such services at the end of the article, so keep reading.</p> <p>When it comes to the NFTs, even when the collection author provided pinning for all assets by default (and they should), you can also pin the assets as a buyer by providing the CID. I will describe how to do this later in the article.</p> <p>   You can read more about pinning and persistence here: <a href=\"https://docs.ipfs.io/concepts/persistence/#persistence-versus-permanence\">docs.ipfs.io/concepts/persistence/#persistence-versus-permanence</a>   Let's see how to get our assets using the CID. </p> <p><strong>What is an IPFS gateway?</strong></p> <p>When you know the CID of your content on the IPFS, you can get it in many different ways. You can use the CLI tools, the desktop apps, or the most straightforward way - special web services called IPFS gateways.</p> <p>IPFS gateway is a standard web service that will locate your content and serve it in the browser. It doesn't matter which gateway you will use. For the same CID, all of them should return the same content. Let's take, for example, two of them as an example:</p> <ul>   <li><a href=\"https://ipfs.io/ipfs/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png\">https://ipfs.io/ipfs/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li>   <li><a href=\"https://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea.ipfs.dweb.link/7894.png\">https://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea.ipfs.dweb.link/7894.png</a></li> </ul> <p>As you can see, these are different web services, but when we use the same CID of the directory and the same file name, we will still get the same image.</p> <p>What is also worth mentioning is that you can use the IPFS URI schema in a Brave browser to get the same image. It is supported only in the Brave browser for now. It will look like this:</p> <ul>   <li><a>ipfs://bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li> </ul> <p>You will find a list of gateways <a href=\"https://ipfs.github.io/public-gateway-checker/\">here</a>. Remember that also Elrond provides a custom IPFS gateway. See the same example below:</p> <ul>   <li><a href=\"https://media.elrond.com/nfts/asset/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png\">https://media.elrond.com/nfts/asset/bafybeigdsbu4tkfzn23ufjugvzo4ht7myazyxl6gtecywtj4vlyvekqxea/7894.png</a></li> </ul> <p>The IPFS gateways are probably the simplest way to access, download or preview your content. Read more about the topic here: <a href=\"https://docs.ipfs.io/concepts/ipfs-gateway/#overview\">docs.ipfs.io/concepts/ipfs-gateway/#overview</a>.</p> <p><strong>Where can I learn more about IPFS?</strong></p> <p>Besides all links from previous chapters, I will leave a couple of links below. The IPFS is a broad and complex topic, but it is worth reading about it and learning more. Let's see where you will find more information:</p> <ul>   <li>Official docs: <a href=\"https://docs.ipfs.io/\">https://docs.ipfs.io/</a></li>   <li>Tutorials: <a href=\"https://proto.school/\">https://proto.school/</a></li>   <li>Youtube channel: <a href=\"https://www.youtube.com/c/IPFSbot\">https://www.youtube.com/c/IPFSbot</a></li>   <li>Awesome IPFS GitHub repo: <a href=\"https://github.com/ipfs/awesome-ipfs\">https://github.com/ipfs/awesome-ipfs</a></li> </ul> <h3>How is it used in the Elrond ecosystem?</h3> <p>Finally, let's jump into the Elrond ecosystem and see how we can use the IPFS when creating the NFTs on the Elrond chain.</p> <p>The main concept of the NFT token on the Elrond blockchain is that it is the ESDT token, so the standard Elrond token, but with additional metadata.</p> <p>There are no strict rules on what your NFT token should look like. I mean, what structure its attributes should have. The main field for keeping the data on-chain is the 'attributes' field. I won't focus much on how NFTs work on the Elrond blockchain because it is a topic for many different articles, and it was already covered partially. Also, see the <a href=\"https://docs.elrond.com/developers/nft-tokens/\">official docs on it</a>.</p> <p>When preparing the NFT, we need to split the data of our NFT token into the small batch, which will be kept on-chain, and all other stuff that will be kept off-chain using IPFS decentralized storage.</p> <p>On Elrond, for on-chain, we will keep only the information about the CIDs for the metadata JSON file with all additional data like traits, description, etc., and the actual asset CID and probably file names. Let's take a closer look and take the example from Elven Tools.</p> <p>Here is the example of the NFT minted using the Elven Tools: <a href=\"https://devnet-explorer.elrond.com/nfts/FTDD-5cdeea-03\">https://devnet-explorer.elrond.com/nfts/FTDD-5cdeea-03</a>.</p> <p>You will see that we have two assets linked using the IPFS gateway. The most popular gateway. The JSON file is the metadata for our token. You can preview its content, but this isn't important for now. The metadata file is added there, but this isn't a standard. The Elven Tools allows choosing if you want it there or not. It isn't required because the information about the metadata CID is located in the attributes. They are not displayed in the explorer directly. But when you preview the API response for this token, you will find that attributes are a base64 encoded string that after decoding will give you something like that: <code>metadata:bafybeifjntwejc7k7dedfaavravhnosc7xe4ceu5zmobjhhbob32uyu57m/93.json</code>. So the same CID and file name as in the assets in the explorer.</p> <p>Based on that, the Elrond API services will prepare additional data for your token. Like media and metadata objects. So it is essential to have such entry in your attributes field.</p> <p>For now, the only supported decentralized storage seems to be IPFS, but I think this is ok. IPFS is the most popular way of storing content in a decentralized manner. But Elrond's services for that will probably be extended in the future. For example, with the Arweave support.</p> <p>To sum up. Metadata, images, and all other assets should be kept off-chain using IPFS because it is much cheaper. The CID for the metadata and assets is critical in how Elrond API services work. The CID and file name for the metadata file should be provided in the 'attributes' field with the defined format and encoded with base64. This will open the door to proper operations on the NFT data and prepare appropriate API responses. It is also used for thumbnails generation and optimizations for assets serving. The metadata JSON file CID in the assets section is optional. Some of the marketplaces require that.</p> <h3>Helpful IPFS services and tools.</h3> <p>Last is the section about essential services commonly used for uploading and managing the assets on IPFS. There are a couple of them, but I want to focus on two here. These are:</p> <ul>   <li><a href=\"https://www.pinata.cloud/\">https://www.pinata.cloud/</a></li>   <li><a href=\"https://nft.storage/\">https://nft.storage/</a></li> </ul> <p>The Pinata is a top-rated service where you can upload a whole directory, and it will be pinned automatically for you. You will get your CID which you can use for your NFTs.</p> <p>The Pinata has free and paid plans. You can choose whatever suits your needs.</p> <p>I don't use Pinata much, but I like their pinning service for CIDs, which are not generated by their service. You could secure your assets even if you didn't upload them using Pinata. It is something that should always be done when you buy NFTs. Just in case.</p> <p>The nft.storage service is my preferred one. The main reason is that it is free, and they also use Filecoin to secure the contents. You can read more about it on their website. And still, all is free.</p> <p>Nft.storage allows uploading single files or CAR files, similar to standard TAR files. The functionality is identical to the Pinata. You will get your CID file, whether it will be a single file or directory/CAR.</p> <p>Both services allow uploading using their web interface or many different tools. The web interface won't be enough when you want to upload a massive set of data because of the browser's limitations. In such a case, you would need to use the CLI tool or any other provided. For example, nft.storage has an excellent <a href=\"https://nft.storage/docs/client/js/\">JavaScript client SDK for their API</a>.</p> <p>Another important thing is to keep in mind that even if you, as the collection creator, have uploaded the files and there is an option to remove them, this doesn't mean that when you remove the files, they will disappear from IPFS. As I mentioned, you can't remove or modify already uploaded content. It can only disappear when it is garbage-collected, which in the case of nft.storage will be hard because the content will also land on the Filecoin. But of course, as the creator, you should keep the files pinned there. Also, every buyer can pin their assets using, for example, Pinata and CIDs.</p> <h3>Summary</h3> <p>Hopefully, I was able to explain some basics and show you the path where you could start learning about decentralized storage and IPFS. The Elven Tools is prepared to consume the IPFS and keep the Elrond best practices so feel free to play around and test things.</p> <p>If you want to contact me, you will find all communication channels here: <a href=\"https://www.elven.tools/about.html\">www.elven.tools/about.html</a>.</p>","excerpt":"IPFS storage is a crucial part of every NFT ecosystem, not only the Elrond. It allows storing and accessing data in a decentralized and trustless way.","publicationDate":"2022-03-26","tags":["articles"],"coverImage":""}]